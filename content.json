{"meta":{"title":"YongQian's Blog","subtitle":"不积跬步无以至千里","description":"今天遭受的所有挫折和磨难，都是明天吹牛逼的资本","author":"Yin Yongqian","url":"http://yongqianvip.github.io"},"pages":[{"title":"标签","date":"2016-09-14T03:37:23.000Z","updated":"2016-09-14T12:58:35.000Z","comments":false,"path":"tags/index.html","permalink":"http://yongqianvip.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RN_Erroe_Xcode8","slug":"RN-Erroe-Xcode8","date":"2016-10-18T02:18:57.000Z","updated":"2016-10-18T02:19:49.000Z","comments":true,"path":"2016/10/18/RN-Erroe-Xcode8/","link":"","permalink":"http://yongqianvip.github.io/2016/10/18/RN-Erroe-Xcode8/","excerpt":"","text":"1 RCTWebSocket Semantic issue 1. 打开RCTSCrollView.m Command+F 搜索@implementation RCTCustomScrollView 只会搜索到一个结果，然后修改： @implementation RCTCustomScrollView { RCTRefreshControl *_refreshControl;//不管原来有什么，在原来的基础上加上这句 } 2. // SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes); (void)SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes); 2 __nw_connection_get_connected_socket_block_invokeXocde控制台不断输出 如下log [] __nw_connection_get_connected_socket_block_invoke * Connection has no connected handler Xcode menu -&gt; Product -&gt; Edit Scheme… Environment Variables -&gt; Add -&gt; Name: “OS_ACTIVITY_MODE”, Value:”disable” Run again 3 Apple Mach-O Linker(Id) Error在TARGETS下 Build setting -&gt; Other Linker Flags -&gt;添加 -lc++","categories":[],"tags":[],"keywords":[]},{"title":"没有迈不过去的坎，也没有翻不过去的墙","slug":"aws_vpn","date":"2016-09-09T07:07:25.000Z","updated":"2016-09-14T13:12:57.000Z","comments":true,"path":"2016/09/09/aws_vpn/","link":"","permalink":"http://yongqianvip.github.io/2016/09/09/aws_vpn/","excerpt":"这里记录一下我是如何在Mac上借助AWS(Amazon Web Services)免费搭建VPN服务器的","text":"这里记录一下我是如何在Mac上借助AWS(Amazon Web Services)免费搭建VPN服务器的 生活用百度，技术用谷歌由于种种原因，我们并不能直接访问谷歌等一些国外网站但是，“没有什么事是程序员不能解决的，如果有，那就让别人解决吧” Q: How to do？ A: Follow me！ 这里要说明一点，服务确实是免费的(为期一年，超过一年将收费)，不过仍然需要一张信用卡，亚马逊需要1美元的授权，只是授权，不会加入账单，在我看来可以理解为押金，如果你用的全部是套餐内的服务，钱是不会被扣的，而如果超出了套餐内容，这笔钱会根据用量扣除，下文也会讲到如何避免。 网上这种类似的教程很多，但是就像穿鞋，合不合脚，只有自己知道。 一、搭建远程服务器登录亚马逊(http://aws.amazon.com/cn/)，没有账号的请自行注册 选择免费试用Amazon EC2 选择系统映像，这里选择Amazon Liunx，当然也可以选择其他的，但是我用的是Amazon Liunx，然后“下一步”由于我这里单纯是为了但见一个VPN服务器，对配置没多大的要求，所以选择 选择实例类型，然后“下一步” 接下来的“配置实例”，“添加存储”直接用默认设置，点“下一步”即可 到“标签实例”中，创建密钥标签，内容自定 “配置安全组件”，默认是”SSH”，建议改为”所有流量”，以后也可以改 “审核”页面，点击”启动”按钮，创建新的密钥对，命名之后点击下载，下载好的.pem文件保存好，保存好，保存好，以后通过SSH登录远程服务器要用，完成后就可以启动实例了。 等待一小会儿，刷新控制面板就可以看到正在运行的实例了。 实例我理解为我的远程服务器，可以在界面上操作它的启动、停止、重启和终止，其中重启不会改变公有IP，其他操作都会改变公有IP，所以进行重启之外的操作之后，Shadowsocks的相关配置记得统一变更 二、SSH登录远程服务器并安装相关程序(Shadowsocks) 右键选中的实例，打开“连接”，弹出信息框 打开终端 首先需要使密钥不公开可见 chmod 400 &lt;*.pem文件路径&gt; SSH登录（命令可以复制上图中的示例） ssh -i &lt;*.pem文件路径&gt; ec2-user@&lt;服务器公有DNS&gt; 根据提示输入yes即可连接远程服务器。 依次执行如下三条命令安装相关的软件 $ sudo yum install -y python-setuptools $ sudo easy_install pip $ sudo pip install shadowsocks 软件安装完成，添加配置文件 创建文件夹 mkdir /etc/configfile vim编辑config.json(vim是一种文本编辑器感兴趣的去这里了解一下) sudo vim /etc/configfile/config.json 粘贴以下内容 { &quot;server_port”:8081, &quot;password”:”123456789”, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, } &nbsp;&nbsp;&nbsp;&nbsp;其中，端口号server_port根据自己情况制定（1024 ~ 65535），密码password自己制定并要牢记，加密方式method默认选aes-256-cfb，这些信息后边用户在终端登录要用到，超时时间timeout自己指定。 &nbsp;&nbsp;&nbsp;&nbsp;另外，如果想给不同端口设置不同密码，参照下边的格式即可 { &quot;port_password&quot;:{ &quot;8088&quot;:&quot;password1&quot;, &quot;8089&quot;:&quot;password2&quot; }, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;timeout&quot;:300 } 编辑完成后按Esc退出编辑模式（回到命令模式） 输入:wq（保存并退出编辑） 启动shadowsocks sudo ssserver -c /etc/configfile/config.json -d start 备注:笔者在执行上述命令时遇到命令不被识别的问题，所以最终只能使用命令全路径ssserver路径通过which ssserver命令可以拿到所以最终我的命令是：/usr/bin/sudo /usr/local/bin/ssserver -c /etc/configfile/config.json -d start 三、本机安装Shadowsocks客户端 本机安装Shadowsocks客户端，看这里http://www.godusevpn.mobi/wiki.html就够了，虽然不买他们的服务，但是看看他们的教程还是可以的嘛🤗🤗🤗 （以Mac为例）按照下图，打开Shadowsocks菜单菜单 -&gt; 服务器 -&gt; 打开服务器设定 配置自己的服务器IP、端口号，加密方式aes-256-cfb,密码 配置完成之后再打开Shadowsocks菜单菜单 -&gt; 服务器 -&gt; 勾选刚才添加的项目 四、Google一下到这里，你应该就可以顺利的访问下边的网站了 http://www.google.comhttp://www.facebook.comhttp://www.twitter.com 五、设置Shadowsocks开机启动有的时候我们需要重启服务器，为避免每次重启服务器之后手动启动Shadowsocks，我们可以把它设置为开机启动 sudo vi /etc/rc.local 在rc.local文件末尾添加如下代码 sudo ssserver -c /etc/configfile/config.json -d start 备注：如果上边也曾遇到过命令不识别的问题，这里也需要拼全路径的/usr/bin/sudo /usr/local/bin/ssserver -c /etc/configfile/config.json -d start 六、如何避免收费虽说我们选的是免费的套餐，但是仍有可能一个不小心信用卡上就多了一笔账单有两种情况： 套餐过期继续使用 所以记得到期的时间，如果不想产生费用，最简单粗暴的方法就是关停使用中的实例，实例终止之后系统会在一定时间内清理掉你得实例 因为你可能在不知情的情况下超出套餐用量 针对这个问题，好在有CloudWatch，通过CloudWatch我们可以设定警告 首先我们看一下AWS免费套餐的标准 对于不做其他用途，仅用于搭建VPN平台的我来说，流量、存储什么的足够了，所以我主要给I/O设置了警报，当然可以结合实际情况，自定义警报类型 打开CloudWatch 选择警报-&gt;创建警报 -&gt; EBS -&gt; 勾选监控指标（卷读取操作） -&gt; 下一步接下来定义警报内容：设置警报阈值，并在通知操作栏中选择通知列表（如果没有，需要新建，包括添加邮箱列表，邮箱确认等一系列步骤，这里不再赘述），最后成功创建警报，警报创建成功后，当指标超过设定的上限时，通知列表中的邮箱会收到来自AWS Notifications发来的警报邮件。 监控不同的指标需要设定不同的警报，所以，再以同样的方法设定卷写入操作的指标监控警报。 通过一系列警报和设置，我们可以提前有所准备，但可能做不到完全避免，同时由于我对AWS也只接触了一天的时间，CloudWatch肯定还有更多强大的功能没有被我发现，所以还有很多工作要做，也希望同学们有新的发现及时分享给大家。","categories":[],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://yongqianvip.github.io/tags/VPN/"}],"keywords":[]},{"title":"iOS开发技巧","slug":"iOS_Tips","date":"2016-08-26T07:07:25.000Z","updated":"2016-09-14T02:31:17.000Z","comments":true,"path":"2016/08/26/iOS_Tips/","link":"","permalink":"http://yongqianvip.github.io/2016/08/26/iOS_Tips/","excerpt":"iOS开发中的一些列小技巧，总有一个你用得到","text":"iOS开发中的一些列小技巧，总有一个你用得到 1、UITableView的Group样式下顶部空白处理在viewWillAppear里面添加如下代码： //分组列表头部空白处理 CGRect frame = myTableView.tableHeaderView.frame; frame.size.height = 0.1; UIView *headerView = [[UIView alloc] initWithFrame:frame]; [myTableView setTableHeaderView:headerView]; 2、UITableView的plain样式下，取消区头停滞效果-(void)scrollViewDidScroll:(UIScrollView *)scrollView { CGFloat sectionHeaderHeight = sectionHead.height; if (scrollView.contentOffset.y&lt;=sectionHeaderHeight&amp;&amp;scrollView;.contentOffset.y&gt;=0) { scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); } else if(scrollView.contentOffset.y&gt;=sectionHeaderHeight) { scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); } } 3、获取某个view所在的控制器-(UIViewController *)viewController { UIViewController *viewController = nil; UIResponder *next = self.nextResponder; while (next) { if ([next isKindOfClass:[UIViewController class]]) { viewController = (UIViewController *)next; break; } next = next.nextResponder; } return viewController; } 4、两种方法删除NSUserDefaults所有记录//方法一 NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier]; [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain]; //方法二 -(void)resetDefaults { NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) { [defs removeObjectForKey:key]; } [defs synchronize]; } 5、打印系统所有已注册的字体名称void enumerateFonts() { for(NSString *familyName in [UIFont familyNames]) { NSLog(@&quot;%@&quot;,familyName); NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName]; for(NSString *fontName in fontNames) { NSLog(@&quot;\\t|- %@&quot;,fontName); } } } 6、获取图片某一点的颜色第一种： -(NSString *)reverseWordsInString:(NSString *)str { NSMutableString *newString = [[NSMutableString alloc] initWithCapacity:str.length]; for (NSInteger i = str.length - 1; i &gt;= 0 ; i --) { unichar ch = [str characterAtIndex:i]; [newString appendFormat:@&quot;%c&quot;, ch]; } return newString; } //第二种： - (NSString*)reverseWordsInString:(NSString*)str { NSMutableString *reverString = [NSMutableString stringWithCapacity:str.length]; [str enumerateSubstringsInRange:NSMakeRange(0, str.length) options:NSStringEnumerationReverse | NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) { [reverString appendString:substring]; }]; return reverString; } 7、禁止锁屏默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。 [UIApplication sharedApplication].idleTimerDisabled = YES; 或 [[UIApplication sharedApplication] setIdleTimerDisabled:YES]; 8、模态推出透明界面UIViewController *vc = [[UIViewController alloc] init]; UINavigationController *na = [[UINavigationController alloc] initWithRootViewController:vc]; if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) { na.modalPresentationStyle = UIModalPresentationOverCurrentContext; } else { self.modalPresentationStyle=UIModalPresentationCurrentContext; } [self presentViewController:na animated:YES completion:nil]; 9、Xcode调试不显示内存占用editSCheme 里面有个选项叫叫做enable zoombie Objects 取消选中 10、显示隐藏文件//显示 defaults write com.apple.finder AppleShowAllFiles -bool true killall Finder //隐藏 defaults write com.apple.finder AppleShowAllFiles -bool false killall Finder 10、iOS跳转到App Store下载应用评分[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=APPID&quot;]]; 11、iOS 获取汉字的拼音+ (NSString *)transform:(NSString *)chinese { //将NSString装换成NSMutableString NSMutableString *pinyin = [chinese mutableCopy]; //将汉字转换为拼音(带音标) CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO); NSLog(@&quot;%@&quot;, pinyin); //去掉拼音的音标 CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO); NSLog(@&quot;%@&quot;, pinyin); //返回最近结果 return pinyin; } 12、手动更改iOS状态栏的颜色- (void)setStatusBarBackgroundColor:(UIColor *)color { UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@&quot;statusBarWindow&quot;] valueForKey:@&quot;statusBar&quot;]; if ([statusBar respondsToSelector:@selector(setBackgroundColor:)]) { statusBar.backgroundColor = color; } } 13、判断当前ViewController是push还是present的方式显示的NSArray *viewcontrollers=self.navigationController.viewControllers; if (viewcontrollers.count &gt; 1) { if ([viewcontrollers objectAtIndex:viewcontrollers.count - 1] == self) { //push方式 [self.navigationController popViewControllerAnimated:YES]; } } else { //present方式 [self dismissViewControllerAnimated:YES completion:nil]; } 14、获取实际使用的LaunchImage图片- (NSString *)getLaunchImageName { CGSize viewSize = self.window.bounds.size; // 竖屏 NSString *viewOrientation = @&quot;Portrait&quot;; NSString *launchImageName = nil; NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;]; for (NSDictionary* dict in imagesDict) { CGSize imageSize = CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]); if (CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]]) { launchImageName = dict[@&quot;UILaunchImageName&quot;]; } } return launchImageName; } 15、iOS在当前屏幕获取第一响应UIWindow * keyWindow = [[UIApplication sharedApplication] keyWindow]; UIView * firstResponder = [keyWindow performSelector:@selector(firstResponder)]; 16、判断对象是否遵循了某协议if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)]) { [self.selectedController performSelector:@selector(onTriggerRefresh)]; } 17、判断view是不是指定视图的子视图BOOL isView = [textView isDescendantOfView:self.view]; 18、NSArray 快速求总和 最大值 最小值 和 平均值NSArray *array = [NSArray arrayWithObjects:@&quot;2.0&quot;, @&quot;2.3&quot;, @&quot;3.0&quot;, @&quot;4.0&quot;, @&quot;10&quot;, nil]; CGFloat sum = [[array valueForKeyPath:@&quot;@sum.floatValue&quot;] floatValue]; CGFloat avg = [[array valueForKeyPath:@&quot;@avg.floatValue&quot;] floatValue]; CGFloat max =[[array valueForKeyPath:@&quot;@max.floatValue&quot;] floatValue]; CGFloat min =[[array valueForKeyPath:@&quot;@min.floatValue&quot;] floatValue]; NSLog(@&quot;%f\\n%f\\n%f\\n%f&quot;,sum,avg,max,min); 19、修改UITextField中Placeholder的文字颜色[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;]; 20、关于NSDateFormatter的格式G: 公元时代，例如AD公元 yy: 年的后2位 yyyy: 完整年 MM: 月，显示为1-12 MMM: 月，显示为英文月份简写,如 Jan MMMM: 月，显示为英文月份全称，如 Janualy dd: 日，2位数表示，如02 d: 日，1-2位显示，如 2 EEE: 简写星期几，如Sun EEEE: 全写星期几，如Sunday aa: 上下午，AM/PM H: 时，24小时制，0-23 K：时，12小时制，0-11 m: 分，1-2位 mm: 分，2位 s: 秒，1-2位 ss: 秒，2位 S: 毫秒 21、获取一个类的所有子类+ (NSArray *) allSubclasses { Class myClass = [self class]; NSMutableArray *mySubclasses = [NSMutableArray array]; unsigned int numOfClasses; Class *classes = objc_copyClassList(&amp;numOfClasses;); for (unsigned int ci = 0; ci &lt; numOfClasses; ci++) { Class superClass = classes[ci]; do{ superClass = class_getSuperclass(superClass); } while (superClass &amp;&amp; superClass != myClass); if (superClass) { [mySubclasses addObject: classes[ci]]; } } free(classes); return mySubclasses; } 22、监测IOS设备是否设置了代理，需要CFNetwork.frameworkNSDictionary *proxySettings = (__bridge NSDictionary *)(CFNetworkCopySystemProxySettings()); NSArray *proxies = (__bridge NSArray *)(CFNetworkCopyProxiesForURL((__bridge CFURLRef _Nonnull)([NSURL URLWithString:@&quot;http://www.baidu.com&quot;]), (__bridge CFDictionaryRef _Nonnull)(proxySettings))); NSLog(@&quot;\\n%@&quot;,proxies); NSDictionary *settings = proxies[0]; NSLog(@&quot;%@&quot;,[settings objectForKey:(NSString *)kCFProxyHostNameKey]); NSLog(@&quot;%@&quot;,[settings objectForKey:(NSString *)kCFProxyPortNumberKey]); NSLog(@&quot;%@&quot;,[settings objectForKey:(NSString *)kCFProxyTypeKey]); if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:@&quot;kCFProxyTypeNone&quot;]) { NSLog(@&quot;没代理&quot;); } else { NSLog(@&quot;设置了代理&quot;); } 23、阿拉伯数字转中文格式+(NSString *)translation:(NSString *)arebic { NSString *str = arebic; NSArray *arabic_numerals = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;0&quot;]; NSArray *chinese_numerals = @[@&quot;一&quot;,@&quot;二&quot;,@&quot;三&quot;,@&quot;四&quot;,@&quot;五&quot;,@&quot;六&quot;,@&quot;七&quot;,@&quot;八&quot;,@&quot;九&quot;,@&quot;零&quot;]; NSArray *digits = @[@&quot;个&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;万&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;亿&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;兆&quot;]; NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals]; NSMutableArray *sums = [NSMutableArray array]; for (int i = 0; i &lt; str.length; i ++) { NSString *substr = [str substringWithRange:NSMakeRange(i, 1)]; NSString *a = [dictionary objectForKey:substr]; NSString *b = digits[str.length -i-1]; NSString *sum = [a stringByAppendingString:b]; if ([a isEqualToString:chinese_numerals[9]]) { if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]]) { sum = b; if ([[sums lastObject] isEqualToString:chinese_numerals[9]]) { [sums removeLastObject]; } }else { sum = chinese_numerals[9]; } if ([[sums lastObject] isEqualToString:sum]) { continue; } } [sums addObject:sum]; } NSString *sumStr = [sums componentsJoinedByString:@&quot;&quot;]; NSString *chinese = [sumStr substringToIndex:sumStr.length-1]; NSLog(@&quot;%@&quot;,str); NSLog(@&quot;%@&quot;,chinese); return chinese; } 24、Base64编码与NSString对象或NSData对象的转换// Create NSData object NSData *nsdata = [@&quot;iOS Developer Tips encoded in Base64&quot; dataUsingEncoding:NSUTF8StringEncoding]; // Get NSString from NSData object in Base64 NSString *base64Encoded = [nsdata base64EncodedStringWithOptions:0]; // Print the Base64 encoded string NSLog(@&quot;Encoded: %@&quot;, base64Encoded); // Let&apos;s go the other way... // NSData from the Base64 encoded str NSData *nsdataFromBase64String = [[NSData alloc] initWithBase64EncodedString:base64Encoded options:0]; // Decoded NSString from the NSData NSString *base64Decoded = [[NSString alloc] initWithData:nsdataFromBase64String encoding:NSUTF8StringEncoding]; NSLog(@&quot;Decoded: %@&quot;, base64Decoded); 25、取消UICollectionView的隐式动画UICollectionView在reloadItems的时候，默认会附加一个隐式的fade动画，有时候很讨厌，尤其是当你的cell是复合cell的情况下(比如cell使用到了UIStackView)。下面几种方法都可以帮你去除这些动画 //方法一 [UIView performWithoutAnimation:^{ [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]]; }]; //方法二 [UIView animateWithDuration:0 animations:^{ [collectionView performBatchUpdates:^{ [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]]; } completion:nil]; }]; //方法三 [UIView setAnimationsEnabled:NO]; [self.trackPanel performBatchUpdates:^{ [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]]; } completion:^(BOOL finished) { [UIView setAnimationsEnabled:YES]; }]; 26、让Xcode的控制台支持LLDB类型的打印打开终端输入三条命令: touch ~/.lldbinit echo display @import UIKit &gt;&gt; ~/.lldbinit echo target stop-hook add -o \\&quot;target stop-hook disable\\&quot; &gt;&gt; ~/.lldbinit 27、CocoaPods pod install/pod update更新慢的问题pod install --verbose --no-repo-update pod update --verbose --no-repo-update 如果不加后面的参数，默认会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少 28、UIImage 占用内存大小UIImage *image = [UIImage imageNamed:@&quot;aa&quot;]; NSUInteger size = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage); 29、GCD timer定时器dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue); dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(timer, ^{ //@&quot;倒计时结束，关闭&quot; dispatch_source_cancel(timer); dispatch_async(dispatch_get_main_queue(), ^{ }); }); dispatch_resume(timer); 30、图片上绘制文字 写一个UIImage的category- (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize { //画布大小 CGSize size=CGSizeMake(self.size.width,self.size.height); //创建一个基于位图的上下文 UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO scale:0.0 [self drawAtPoint:CGPointMake(0.0,0.0)]; //文字居中显示在画布上 NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy]; paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping; paragraphStyle.alignment=NSTextAlignmentCenter;//文字居中 //计算文字所占的size,文字居中显示在画布上 CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:fontSize]}context:nil].size; CGFloat width = self.size.width; CGFloat height = self.size.height; CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height); //绘制文字 [title drawInRect:rect withAttributes:@{ NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle}]; //返回绘制的新图形 UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage; } 31、查找一个视图的所有子视图- (NSMutableArray *)allSubViewsForView:(UIView *)view { NSMutableArray *array = [NSMutableArray arrayWithCapacity:0]; for (UIView *subView in view.subviews) { [array addObject:subView]; if (subView.subviews.count &gt; 0) { [array addObjectsFromArray:[self allSubViewsForView:subView]]; } } return array; } 32、计算文件大小//文件大小 - (long long)fileSizeAtPath:(NSString *)path { NSFileManager *fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:path]) { long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize; return size; } return 0; } //文件夹大小 - (long long)folderSizeAtPath:(NSString *)path { NSFileManager *fileManager = [NSFileManager defaultManager]; long long folderSize = 0; if ([fileManager fileExistsAtPath:path]) { NSArray *childerFiles = [fileManager subpathsAtPath:path]; for (NSString *fileName in childerFiles) { NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName]; if ([fileManager fileExistsAtPath:fileAbsolutePath]) { long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize; folderSize += size; } } } return folderSize; } 33、UIView设置部分圆角你是不是也遇到过这样的问题，一个button或者label，只要右边的两个角圆角，或者只要一个圆角。该怎么办呢。这就需要图层蒙版来帮助我们了 CGRect rect = view.bounds; CGSize radio = CGSizeMake(30, 30);//圆角尺寸 UIRectCorner corner = UIRectCornerTopLeft|UIRectCornerTopRight;//这只圆角位置 UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio]; CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//创建shapelayer masklayer.frame = view.bounds; masklayer.path = path.CGPath;//设置路径 view.layer.mask = masklayer; 34、取上整与取下整floor(x),有时候也写做Floor(x)，其功能是“下取整”，即取不大于x的最大整数 例如： x=3.14，floor(x)=3 y=9.99999，floor(y)=9 与floor函数对应的是ceil函数，即上取整函数。 ceil函数的作用是求不小于给定实数的最小整数。 ceil(2)=ceil(1.2)=cei(1.5)=2.00 floor函数与ceil函数的返回值均为double型 35、计算字符串字符长度，一个汉字算两个字符//方法一： - (int)convertToInt:(NSString*)strtemp { int strlength = 0; char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding]; for (int i=0 ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding] ;i++) { if (*p) { p++; strlength++; } else { p++; } } return strlength; } //方法二： -(NSUInteger) unicodeLengthOfString: (NSString *) text { NSUInteger asciiLength = 0; for (NSUInteger i = 0; i &lt; text.length; i++) { unichar uc = [text characterAtIndex: i]; asciiLength += isascii(uc) ? 1 : 2; } return asciiLength; } 36、给UIView设置图片UIImage *image = [UIImage imageNamed:@&quot;image&quot;]; self.MYView.layer.contents = (__bridge id _Nullable)(image.CGImage); self.MYView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5); 37、防止scrollView手势覆盖侧滑手势[scrollView.panGestureRecognizerrequireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer]; 38、去掉导航栏返回的back标题[[UIBarButtonItemappearance]setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)forBarMetrics:UIBarMetricsDefault]; 39、字符串中是否含有中文+ (BOOL)checkIsChinese:(NSString *)string { for (int i=0; i&lt;string.length; i++) { unichar ch = [string characterAtIndex:i]; if (0x4E00 &lt;= ch &amp;&amp; ch &lt;= 0x9FA5) { return YES; } } return NO; } 40、dispatch_group的使用dispatch_group_t dispatchGroup = dispatch_group_create(); dispatch_group_enter(dispatchGroup); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;第一个请求完成&quot;); dispatch_group_leave(dispatchGroup); }); dispatch_group_enter(dispatchGroup); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;第二个请求完成&quot;); dispatch_group_leave(dispatchGroup); }); dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^(){ NSLog(@&quot;请求完成&quot;); }); 41、UITextField每四位加一个空格,实现代理- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string { // 四位加一个空格 if ([string isEqualToString:@&quot;&quot;]) { // 删除字符 if ((textField.text.length - 2) % 5 == 0) { textField.text = [textField.text substringToIndex:textField.text.length - 1]; } return YES; } else { if (textField.text.length % 5 == 0) { textField.text = [NSString stringWithFormat:@&quot;%@ &quot;, textField.text]; } } return YES; } 42、获取私有属性和成员变量 #import //获取私有属性 比如设置UIDatePicker的字体颜色 - (void)setTextColor { //获取所有的属性，去查看有没有对应的属性 unsigned int count = 0; objc_property_t *propertys = class_copyPropertyList([UIDatePicker class], &amp;count); for(int i = 0;i &lt; count;i ++) { //获得每一个属性 objc_property_t property = propertys[i]; //获得属性对应的nsstring NSString *propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; //输出打印看对应的属性 NSLog(@&quot;propertyname = %@&quot;,propertyName); if ([propertyName isEqualToString:@&quot;textColor&quot;]) { [datePicker setValue:[UIColor whiteColor] forKey:propertyName]; } } } //获得成员变量 比如修改UIAlertAction的按钮字体颜色 unsigned int count = 0; Ivar *ivars = class_copyIvarList([UIAlertAction class], &amp;count); for(int i =0;i &lt; count;i ++) { Ivar ivar = ivars[i]; NSString *ivarName = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding]; NSLog(@&quot;uialertion.ivarName = %@&quot;,ivarName); if ([ivarName isEqualToString:@&quot;_titleTextColor&quot;]) { [alertOk setValue:[UIColor blueColor] forKey:@&quot;titleTextColor&quot;]; [alertCancel setValue:[UIColor purpleColor] forKey:@&quot;titleTextColor&quot;]; } } 43、获取手机安装的应用Class c =NSClassFromString(@&quot;LSApplicationWorkspace&quot;); id s = [(id)c performSelector:NSSelectorFromString(@&quot;defaultWorkspace&quot;)]; NSArray *array = [s performSelector:NSSelectorFromString(@&quot;allInstalledApplications&quot;)]; for (id item in array) { NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;applicationIdentifier&quot;)]); //NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;bundleIdentifier&quot;)]); NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;bundleVersion&quot;)]); NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;shortVersionString&quot;)]); } 44、判断两个日期是否在同一周 写在NSDate的category里面- (BOOL)isSameDateWithDate:(NSDate *)date { //日期间隔大于七天之间返回NO if (fabs([self timeIntervalSinceDate:date]) &gt;= 7 * 24 *3600) { return NO; } NSCalendar *calender = [NSCalendar currentCalendar]; calender.firstWeekday = 2;//设置每周第一天从周一开始 //计算两个日期分别为这年第几周 NSUInteger countSelf = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:self]; NSUInteger countDate = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:date]; //相等就在同一周，不相等就不在同一周 return countSelf == countDate; } 45、应用内打开系统设置界面//iOS8之后 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]]; //如果App没有添加权限，显示的是设定界面。如果App有添加权限（例如通知），显示的是App的设定界面。 //iOS8之前 //先添加一个url type如下图，在代码中调用如下代码,即可跳转到设置页面的对应项 [[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root=WIFI&quot;]]; 可选值如下： About — prefs:root=General&amp;path=About Accessibility — prefs:root=General&amp;path=ACCESSIBILITY Airplane Mode On — prefs:root=AIRPLANE_MODE Auto-Lock — prefs:root=General&amp;path=AUTOLOCK Brightness — prefs:root=Brightness Bluetooth — prefs:root=General&amp;path=Bluetooth Date &amp; Time — prefs:root=General&amp;path=DATE_AND_TIME FaceTime — prefs:root=FACETIME General — prefs:root=General Keyboard — prefs:root=General&amp;path=Keyboard iCloud — prefs:root=CASTLE iCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP International — prefs:root=General&amp;path=INTERNATIONAL Location Services — prefs:root=LOCATION_SERVICES Music — prefs:root=MUSIC Music Equalizer — prefs:root=MUSIC&amp;path=EQ Music Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimit Network — prefs:root=General&amp;path=Network Nike + iPod — prefs:root=NIKE_PLUS_IPOD Notes — prefs:root=NOTES Notification — prefs:root=NOTIFICATI*****_ID Phone — prefs:root=Phone Photos — prefs:root=Photos Profile — prefs:root=General&amp;path=ManagedConfigurationList Reset — prefs:root=General&amp;path=Reset Safari — prefs:root=Safari Siri — prefs:root=General&amp;path=Assistant Sounds — prefs:root=Sounds Software Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK Store — prefs:root=STORE Twitter — prefs:root=TWITTER Usage — prefs:root=General&amp;path=USAGE VPN — prefs:root=General&amp;path=Network/VPN Wallpaper — prefs:root=Wallpaper Wi-Fi — prefs:root=WIFI 46、动画暂停再开始-(void)pauseLayer:(CALayer *)layer { CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; layer.speed = 0.0; layer.timeOffset = pausedTime; } -(void)resumeLayer:(CALayer *)layer { CFTimeInterval pausedTime = [layer timeOffset]; layer.speed = 1.0; layer.timeOffset = 0.0; layer.beginTime = 0.0; CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; layer.beginTime = timeSincePause; } 47、iOS中数字的格式化//通过NSNumberFormatter，同样可以设置NSNumber输出的格式。例如如下代码： NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init]; formatter.numberStyle = NSNumberFormatterDecimalStyle; NSString *string = [formatter stringFromNumber:[NSNumber numberWithInt:123456789]]; NSLog(@&quot;Formatted number string:%@&quot;,string); //输出结果为：[1223:403] Formatted number string:123,456,789 //其中NSNumberFormatter类有个属性numberStyle，它是一个枚举型，设置不同的值可以输出不同的数字格式。该枚举包括： typedef NS_ENUM(NSUInteger, NSNumberFormatterStyle) { NSNumberFormatterNoStyle = kCFNumberFormatterNoStyle, NSNumberFormatterDecimalStyle = kCFNumberFormatterDecimalStyle, NSNumberFormatterCurrencyStyle = kCFNumberFormatterCurrencyStyle, NSNumberFormatterPercentStyle = kCFNumberFormatterPercentStyle, NSNumberFormatterScientificStyle = kCFNumberFormatterScientificStyle, NSNumberFormatterSpellOutStyle = kCFNumberFormatterSpellOutStyle }; //各个枚举对应输出数字格式的效果如下：其中第三项和最后一项的输出会根据系统设置的语言区域的不同而不同。 [1243:403] Formatted number string:123456789 [1243:403] Formatted number string:123,456,789 [1243:403] Formatted number string:￥123,456,789.00 [1243:403] Formatted number string:-539,222,988% [1243:403] Formatted number string:1.23456789E8 [1243:403] Formatted number string:一亿二千三百四十五万六千七百八十九 48、如何获取WebView所有的图片地址，在网页加载完成时，通过js获取图片和添加点击的识别方式 //UIWebView - (void)webViewDidFinishLoad:(UIWebView *)webView { //这里是js，主要目的实现对url的获取 static NSString * const jsGetImages = @&quot;function getImages(){\\ var objs = document.getElementsByTagName(\\&quot;img\\&quot;);\\ var imgScr = &apos;&apos;;\\ for(var i=0;i&lt;objs.length;i++){\\ imgScr = imgScr + objs[i].src + &apos;+&apos;;\\ };\\ return imgScr;\\ };&quot;; [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法 NSString *urlResult = [webView stringByEvaluatingJavaScriptFromString:@&quot;getImages()&quot;]; NSArray *urlArray = [NSMutableArray arrayWithArray:[urlResult componentsSeparatedByString:@&quot;+&quot;]]; //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组 } //WKWebView - (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation { static NSString * const jsGetImages = @&quot;function getImages(){\\ var objs = document.getElementsByTagName(\\&quot;img\\&quot;);\\ var imgScr = &apos;&apos;;\\ for(var i=0;i&lt;objs.length;i++){\\ imgScr = imgScr + objs[i].src + &apos;+&apos;;\\ };\\ return imgScr;\\ };&quot;; [webView evaluateJavaScript:jsGetImages completionHandler:nil]; [webView evaluateJavaScript:@&quot;getImages()&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) { NSLog(@&quot;%@&quot;,result); }]; } 49、获取到webview的高度CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@&quot;document.body.offsetHeight&quot;] floatValue]; 50、navigationBar变为纯透明//第一种方法 //导航栏纯透明 [self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; //去掉导航栏底部的黑线 self.navigationBar.shadowImage = [UIImage new]; //第二种方法 [[self.navigationBar subviews] objectAtIndex:0].alpha = 0; //tabbar变为透明 [self.tabBar setBackgroundImage:[UIImage new]]; self.tabBar.shadowImage = [UIImage new]; 51、navigationBar根据滑动距离的渐变色实现//第一种 - (void)scrollViewDidScroll:(UIScrollView *)scrollView { CGFloat offsetToShow = 200.0;//滑动多少就完全显示 CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow; [[self.navigationController.navigationBar subviews] objectAtIndex:0].alpha = alpha; } //第二种 - (void)scrollViewDidScroll:(UIScrollView *)scrollView { CGFloat offsetToShow = 200.0; CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow; [self.navigationController.navigationBar setShadowImage:[UIImage new]]; [self.navigationController.navigationBar setBackgroundImage:[self imageWithColor:[[UIColor orangeColor]colorWithAlphaComponent:alpha]] forBarMetrics:UIBarMetricsDefault]; } //生成一张纯色的图片 - (UIImage *)imageWithColor:(UIColor *)color { CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return theImage; } 52、iOS 开发中一些相关的路径模拟器的位置: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 文档安装位置: /Applications/Xcode.app/Contents/Developer/Documentation/DocSets 插件保存路径: ~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 自定义代码段的保存路径: ~/Library/Developer/Xcode/UserData/CodeSnippets/ 如果找不到CodeSnippets文件夹，可以自己新建一个CodeSnippets文件夹。 描述文件路径 ~/Library/MobileDevice/Provisioning Profiles 53、navigationItem的BarButtonItem如何紧靠屏幕右边界或者左边界？一般情况下，右边的item会和屏幕右侧保持一段距离，下面是通过添加一个负值宽度的固定间距的item来解决，也可以改变宽度实现不同的间隔： UIImage *img = [[UIImage imageNamed:@&quot;icon_cog&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; //宽度为负数的固定间距的系统item UIBarButtonItem *rightNegativeSpacer = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; [rightNegativeSpacer setWidth:-15]; UIBarButtonItem *rightBtnItem1 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)]; UIBarButtonItem *rightBtnItem2 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)]; self.navigationItem.rightBarButtonItems = @[rightNegativeSpacer,rightBtnItem1,rightBtnItem2];","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yongqianvip.github.io/tags/iOS/"}],"keywords":[]},{"title":"React-Native设置自定义字体文件","slug":"RN_iconfont","date":"2016-08-26T07:07:25.000Z","updated":"2016-09-13T07:57:36.000Z","comments":true,"path":"2016/08/26/RN_iconfont/","link":"","permalink":"http://yongqianvip.github.io/2016/08/26/RN_iconfont/","excerpt":"今天主要说说如何通过字体文件加载应用中的一些图标 首先推荐一个网站iconfont-阿里巴巴矢量图标库，这里有海量的图标，可以下载你想要的各种矢量图标，你也可以在注册并登陆账号后，把自己想要的图标打包、下载为文件","text":"今天主要说说如何通过字体文件加载应用中的一些图标 首先推荐一个网站iconfont-阿里巴巴矢量图标库，这里有海量的图标，可以下载你想要的各种矢量图标，你也可以在注册并登陆账号后，把自己想要的图标打包、下载为文件 关于&lt;Text&gt;组件 通过fontFamily可以指定&lt;Text&gt;显示的字体文件，下文将详细说明 代码 &lt;View style={{backgroundColor:'white',width:width-44,height: 36,marginTop: 2,flexDirection:'row',alignItems: 'center',justifyContent: 'space-around',}} &gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe603;&lt;/Text&gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe602;&lt;/Text&gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe604;&lt;/Text&gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe605;&lt;/Text&gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe600;&lt;/Text&gt; &lt;/View&gt; 效果图： 下面说重点 从阿里巴巴矢量图标库中选择适合的图标，并打包下载 下载后得到如下文件，iconfont.tff即为所需文件 在根工程目录下创建assets/fonts/文件夹，导入iconfont.ttf文件 1. iOS把fonts文件夹拖到iOS工程目录下 另外还需要在info.plist文件key为 Fonts provided by application的Array中添加item fonts/iconfont.ttf，到此为止，已经可以在RN项目中使用对应fontFamily:iconfont中的字体图标了 2. Android之所以在工程目录下创建assets/fonts这样的路径，就是为了iOS和Android统一，因为Android必须要把字体文件放在[project root]/android/app/src/main/assets/fonts/文件夹下才能生效，好吧，我们把工程目录下的assets拷贝一份到Android/app/src/main目录下 3. 使用&lt;View style={{backgroundColor:'white',width:width-44,height: 36,marginTop: 2,flexDirection:'row',alignItems: 'center',justifyContent: 'space-around',}} &gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe603;&lt;/Text&gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe602;&lt;/Text&gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe604;&lt;/Text&gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe605;&lt;/Text&gt; &lt;Text style={{ color: 'red', fontFamily:'iconfont',fontSize: 30 }}&gt;&amp;#xe600;&lt;/Text&gt; &lt;/View&gt; 效果就是文章开篇的效果图了 4. 弊端图标对应的unicode码(如：&amp;#xe602;``&amp;#xe603;``&amp;#xe604;``&amp;#xe605;)跟显示的图标没有直接的对应关系","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://yongqianvip.github.io/tags/React-Native/"}],"keywords":[]},{"title":"解决Xcode编译报错：Can't find 'node' binary to build React Native bundle","slug":"RN_Xcode_Can'tFindNode","date":"2016-08-24T07:07:25.000Z","updated":"2016-09-13T08:00:22.000Z","comments":true,"path":"2016/08/24/RN_Xcode_Can'tFindNode/","link":"","permalink":"http://yongqianvip.github.io/2016/08/24/RN_Xcode_Can'tFindNode/","excerpt":"刚开始接触React-Native的时候我曾遇到一个错，最近发现有人也在问这个问题，所以我在这里记一下，供同学参考","text":"刚开始接触React-Native的时候我曾遇到一个错，最近发现有人也在问这个问题，所以我在这里记一下，供同学参考 开发React-Native项目需要搭建一系列开发环境，环境搭好之后，我再Xcode上编译的过程中遇到了一个错误： error: Can&apos;t find &apos;node&apos; binary to build React Native bundle If you have non-standard nodejs installation, select your project in Xcode, find &apos;Build Phases&apos; - &apos;Bundle React Native code and images&apos; and change NODE_BINARY to absolute path to your node executable (you can find it by invoking &apos;which node&apos; in the terminal) 一开始面对这个错误真的是束手无策，后来仔细阅读错误日志之后才发现自己是多么可笑，只能怪自己对英文不敏感，上边的错误日志翻译过来就是： 如果你使用了非标准的 nodejs 安装流程， 在Xcode中选择Project -&gt; Build Phases -&gt; Bundle React Native code and images， 把NODE_BINARY改为node可执行文件的绝对路径 你可以在终端命令行中执行 `$ which node` 来查看你当前node的绝对路径 好了，这下明白多了，我的nodejs是从官网下载的tar包解压手动安装的，所以export NODE_BINARY=node是不行的，需要换成node的绝对路径 //终端执行 $ which node //输出node的绝对路径 按照下图替换掉node","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://yongqianvip.github.io/tags/React-Native/"}],"keywords":[]},{"title":"React-Native项目中使用TabBar","slug":"RN_TabBar","date":"2016-08-16T07:07:25.000Z","updated":"2016-09-13T08:15:31.000Z","comments":true,"path":"2016/08/16/RN_TabBar/","link":"","permalink":"http://yongqianvip.github.io/2016/08/16/RN_TabBar/","excerpt":"之前的文章讲述了在RN项目中如何使用NavigationBar，如何调用原生模块，以及集成下拉刷新和上拉加载更多的功能，今天介绍一个第三方插件react-native-tab-navigator，讲述我是如何使用它在RN项目中使用TabBar","text":"之前的文章讲述了在RN项目中如何使用NavigationBar，如何调用原生模块，以及集成下拉刷新和上拉加载更多的功能，今天介绍一个第三方插件react-native-tab-navigator，讲述我是如何使用它在RN项目中使用TabBar项目源码在这里 安装插件 1$ npm install react-native-tab-navigator --save 使用就我的demo来说：Demo中包含了Navigator管理的一系列视图，我尝试过使用一个Tab管理多个由Navigator管理的一系列视图(这跟我之前的iOS开发经验有关，在iOS中Application的根视图是TabBarController，这个TabBarController管理多个由NavigationController管理的一系列ViewController） 但是这有一个问题： 场景切换的时候可能有隐藏TabBar的需求，按照刚才说的方法，我需要set一个值来控制tabbar的height和overflow，又由于component的生命周期函数中没有类似于iOS中-（void)viewWillAppear;的方法，所以没有很好的方法把隐藏的tabbar再显示出来（如果你有解决这个问题的方法，请告诉我）。 那么换一种思路： 把管理一系列视图的Tab交由一个Navigator管理，虽然这样违背了iOS开发的普通思路，但是就目前在RN项目中，没有发现太大的问题（有一个问题是只有一级页面显示TabBar，所有二级页面全部不显示，不过就国内大多数应用设计风格来看，这个问题也不算是问题）。 react-native-vector-icons这是一个图标库，有兴趣话可以去这里深入了解，简单使用请执行下边两条命令即可 12$ npm install react-native-vector-icons --save$ rnpm link 使用： 12import Icon from &apos;react-native-vector-icons/Ionicons&apos;;&lt;Icon name=&#123; &apos;ios-home&apos; &#125; 关键部分代码 1234567891011121314151617181920212223242526272829//root.jsimport React from &apos;react&apos;import &#123; Navigator&#125; from &apos;react-native&apos;;import &#123; Provider &#125; from &apos;react-redux&apos;import configureStore from &apos;./store/store.js&apos;import App from &apos;./containers/app.js&apos;const store = configureStore();class Root extends React.Component &#123; render() &#123; return ( &lt;Provider store=&#123; store &#125;&gt; //在原来&lt;App /&gt;的基础上添加Navigator &lt;Navigator initialRoute=&#123;&#123; component: App &#125;&#125; configureScene=&#123;(route) =&gt; &#123; return Navigator.SceneConfigs.FloatFromRight; &#125;&#125; renderScene=&#123;(route, navigator) =&gt; &#123; let Component = route.component; return &lt;Component &#123;...route.params&#125; navigator=&#123;navigator&#125; /&gt; &#125;&#125; /&gt; &lt;/Provider&gt; ); &#125;&#125;export default Root; 1234567891011121314151617181920212223242526//app.js ( render()&#123;&#125; ) render() &#123; const &#123; reducer &#125; = this.props; console.log(&quot;============&quot;,reducer.tabbarHeight); return ( &lt;TabNavigator tabBarStyle=&#123;&#123; backgroundColor:&apos;white&apos; &#125;&#125; style=&#123;&#123;backgroundColor: &apos;white&apos;&#125;&#125;&gt; &lt;TabNavigator.Item title=&quot;主页&quot; selected=&#123;this.state.selectedTab === &apos;home&apos;&#125; renderIcon=&#123;() =&gt; &lt;Icon name=&#123; &apos;ios-home&apos; &#125; size=&#123;30&#125; color=&#123;&apos;gray&apos;&#125;/&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Icon name=&#123; &apos;ios-home&apos; &#125; size=&#123;30&#125; color=&#123;&apos;#4E78E7&apos;&#125;/&gt;&#125; onPress=&#123;() =&gt; this.setState(&#123; selectedTab: &apos;home&apos; &#125;)&#125;&gt; &lt;ProductListContainer &#123;...this.props&#125; /&gt; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item title=&quot;其他&quot; selected=&#123;this.state.selectedTab === &apos;other&apos;&#125; renderIcon=&#123;() =&gt; &lt;Icon name=&#123; &apos;ios-more&apos; &#125; size=&#123;30&#125; color=&#123;&apos;gray&apos;&#125;/&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Icon name=&#123; &apos;ios-more&apos; &#125; size=&#123;30&#125; color=&#123;&apos;#4E78E7&apos;&#125;/&gt;&#125; onPress=&#123;() =&gt; this.setState(&#123; selectedTab: &apos;other&apos; &#125;)&#125;&gt; &lt;OtherContainer &#123;...this.props&#125;/&gt; &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt; ); &#125; 效果图","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://yongqianvip.github.io/tags/React-Native/"}],"keywords":[]},{"title":"React-Native中通过JS调用原生模块","slug":"RNDemoToast","date":"2016-08-03T07:07:25.000Z","updated":"2016-09-13T08:21:07.000Z","comments":true,"path":"2016/08/03/RNDemoToast/","link":"","permalink":"http://yongqianvip.github.io/2016/08/03/RNDemoToast/","excerpt":"官方教程中有讲述在RN中如何集成原生模块（iOS日历组件）这里我也写了一个简单的示例，目标是 实现消息提示框（Toast）","text":"官方教程中有讲述在RN中如何集成原生模块（iOS日历组件）这里我也写了一个简单的示例，目标是 实现消息提示框（Toast）源码还在这里 一、iOS在React Native中，一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类，其中RCT是ReaCT的缩写。 1、原生部分： NativeToast.h 1234567#import &quot;RCTBridgeModule.h&quot;#import &quot;RCTLog.h&quot;#import &lt;UIKit/UIKit.h&gt;@interface NativeToast : NSObject &lt;RCTBridgeModule&gt;@end NativeToast.m 必须明确的声明要给Javascript导出的方法，否则React Native不会导出任何方法。声明通过RCT_EXPORT_METHOD()宏来实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#import &quot;NativeToast.h&quot;#import &quot;Global.h&quot;@implementation NativeToast RCT_EXPORT_MODULE();#pragma mark iOS Native ToastRCT_EXPORT_METHOD(showMessage:(NSString *)message showTime:(NSInteger)showTime positions:(NSString *)position)&#123; NSLog(@&quot;__canshu position = %@ showTime = %ld&quot;,position,showTime); UIWindow *window = [UIApplication sharedApplication].keyWindow; UIView *showView = [[UIView alloc] init]; [showView setUserInteractionEnabled:NO]; dispatch_async(dispatch_get_main_queue(), ^&#123; [showView setBackgroundColor:[UIColor colorWithRed:0 green:0 blue:0 alpha:0.8f]]; showView.layer.cornerRadius = 5.0f; showView.layer.masksToBounds = YES; [window addSubview:showView]; UILabel *label = [[UILabel alloc] init]; label.text = message; label.textColor = [UIColor whiteColor]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = 1; label.numberOfLines = 0; label.font = [UIFont boldSystemFontOfSize:TOAST_FONT_SIZE]; CGRect realRect = [message boundingRectWithSize:CGSizeMake(TOAST_MAX_WIDTH, TOAST_MAX_HEIGHT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:label.font&#125; context:nil]; CGSize labelSize = realRect.size; labelSize.height = labelSize.height &lt; TOAST_MIN_HEIGHT ? TOAST_MIN_HEIGHT : labelSize.height; labelSize.width = labelSize.width &lt; TOAST_MIN_WIDTH ? TOAST_MIN_WIDTH : labelSize.width; label.frame = CGRectMake(10, 5, labelSize.width, labelSize.height); [showView addSubview:label]; CGRect rect = [[UIScreen mainScreen] bounds]; CGSize size = rect.size; CGFloat width = size.width; CGFloat height = size.height; CGFloat positionPoint = 0.5; if (position) &#123; if ([position isEqualToString:@&quot;top&quot;]) &#123; positionPoint = 0.2; &#125;else if ([position isEqualToString:@&quot;center&quot;])&#123; positionPoint = 0.5; &#125;else if ([position isEqualToString:@&quot;bottom&quot;])&#123; positionPoint = 0.8; &#125; &#125; NSInteger realShowTime = showTime; if (realShowTime &lt; 1) &#123; realShowTime = 1; &#125;else if (realShowTime &gt; 5)&#123; realShowTime = 5; &#125; showView.frame = CGRectMake((width - labelSize.width - 20) / 2, height * positionPoint, labelSize.width + 20, labelSize.height + 10); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(realShowTime * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [UIView animateWithDuration:1 animations:^&#123; showView.alpha = 0; &#125; completion:^(BOOL finished)&#123; [showView removeFromSuperview]; &#125;]; &#125;); &#125;);&#125;@end 通过上边的代码我们就导出了一个“showMessage”的方法，接受三个参数，这个方法可以在JS内部调用 2、JS中调用ListViewLoadMore/app/components/ProductImageShow.js import { //... NativeModules, } from &apos;react-native&apos; class ProductImageShow extends Component { //... _toast() { // showMessage(&apos;提示信息内容&apos;,&apos;显示时长1~5秒&apos;,&apos;位置[&apos;top&apos;,&apos;center&apos;,&apos;bottom&apos;]&apos;) NativeModules.NativeToast.showMessage( `提示信息\\n可以控制显示的时间\\nshowTime:[1~5]\\n可以控制提示信息显示的位置\\nposition:[&apos;top&apos;,&apos;center&apos;,&apos;bottom&apos;]`, 5, &apos;center&apos; ) } render() { return ( &lt;View style={ styles.mainView }&gt; //... &lt;TouchableOpacity onPress={ this._toast.bind(this) }&gt; &lt;View style={ styles.bottomTitleView }&gt; &lt;Text style={ styles.bottomTitle }&gt;点击图片可以去图文详情页&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) } } 3、效果图 二、Android####….待补充。。。。","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://yongqianvip.github.io/tags/React-Native/"}],"keywords":[]},{"title":"Reat-Native中使用Navigatior和自定义NavigationBar","slug":"RNNavigationBar","date":"2016-08-01T07:07:25.000Z","updated":"2016-09-13T08:21:45.000Z","comments":true,"path":"2016/08/01/RNNavigationBar/","link":"","permalink":"http://yongqianvip.github.io/2016/08/01/RNNavigationBar/","excerpt":"上一次我在这里记录了我是如何处理上拉加载更多和下拉刷新的，这次是应用中的导航功能以及自定义导航栏NavigationBar","text":"上一次我在这里记录了我是如何处理上拉加载更多和下拉刷新的，这次是应用中的导航功能以及自定义导航栏NavigationBar源码还在这里 Navigator（RN提供的组件）只要App不止有一个场景，那么这个App肯定少不了一个导航控制器 (iOS中的NavigationController) Navigator是RN提供的官方组件，兼顾了iOS和Android，这里有一个关于Navigator很详细的教程 这次要用Navigator实现 【首页（商品列表） --&gt; 图片详情页 --&gt; 图文详情页】这一系列的场景切换，另外在“图文详情”页实现了通过滚动视图的偏移量控制NavigationBar渐隐、渐现 截取关键代码 root.js &apos;use strict&apos;; import React from &apos;react&apos; import { Provider } from &apos;react-redux&apos; import configureStore from &apos;./store/store.js&apos; import App from &apos;./containers/app.js&apos; const store = configureStore(); export default class Root extends React.Component { constructor(props) { super(props); } render() { return ( &lt;Provider store={ store }&gt; &lt;App /&gt; &lt;/Provider&gt; ); } } app.js 把`ProductListContainer`设置为根视图， import React from &apos;react&apos;; import { View, Navigator } from &apos;react-native&apos;; import ProductListContainer from &apos;./ProductListContainer&apos; export default class App extends React.Component { render() { let defaultComponent = ProductListContainer; return ( &lt;Navigator initialRoute={{ component: defaultComponent }} configureScene={(route) =&gt; { return Navigator.SceneConfigs.FloatFromRight; }} renderScene={(route, navigator) =&gt; { let Component = route.component; return &lt;Component {...route.params} navigator={navigator} /&gt; // 上面的route.params 是为了方便后续界面间传递参数用的 }} /&gt; ); } } 自定义NavitagionBar NavBarCommon.js(名字以后肯能会改) ListViewLoadMore/app/common/NavBarCommon.js render() { // leftTitle和leftImage 优先判断leftTitle (即 文本按钮和图片按钮优先显示文本按钮) const { title, leftTitle, leftImage, leftAction, rightTitle, rightImage, rightAction } = this.props; return ( &lt;View style={[styles.barView, this.props.style]}&gt; &lt;View style={ styles.showView }&gt; { (()=&gt;{ if (leftTitle) { return &lt;TouchableOpacity style={styles.leftNav} onPress={ ()=&gt;{leftAction()} }&gt; &lt;View style={{alignItems: 'center'}}&gt; &lt;Text style={styles.barButton}&gt;{leftTitle}&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; } else if (leftImage) { return &lt;TouchableOpacity style={styles.leftNav} onPress={ ()=&gt;{leftAction()} }&gt; &lt;View style={{alignItems: 'center'}}&gt; &lt;Image source={ leftImage }/&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; }; })() } { (()=&gt;{ if (title) { return &lt;Text style={styles.title}&gt;{title || &apos;&apos;}&lt;/Text&gt; } })() } { (()=&gt;{ if (rightTitle) { return &lt;TouchableOpacity style={styles.rightNav} onPress={ ()=&gt;{rightAction()} }&gt; &lt;View style={{alignItems: 'center'}}&gt; &lt;Text style={styles.barButton}&gt;{rightTitle}&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; } else if (rightImage) { return &lt;TouchableOpacity style={styles.rightNav} onPress={ ()=&gt;{rightAction()} }&gt; &lt;View style={{alignItems: 'center'}}&gt; &lt;Image source={ rightImage }/&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; } })() } &lt;/View&gt; &lt;/View&gt; ) } 调用的方法和示例：首先引入组件 import NavigationBar from &apos;../common/NavBarCommon.js&apos; 1 最简单的样式 只有标题 &lt;NavigationBar title={&apos;首页&apos;}/&gt; 2 标题、左边按钮 &lt;NavigationBar style={{opacity: this.state.navOpacity}} title={&apos;图文详情&apos;} leftImage={ backIcon } leftAction={ this._backToFront.bind(this) }/&gt; 3 标题、左边按钮、右边按钮 &lt;NavigationBar title={&apos;图片详情&apos;} leftImage={ backIcon } leftAction={ this._backToFront.bind(this) } rightTitle={&apos;去看图文详情&apos;} rightImage={ backIcon } rightAction={ this._toAnotherDetail.bind(this) } /&gt; NavigationBar上的所有部分都是可选项，可以什么都不设置，那就是一个空白的导航栏那么对应的只要设置相应的文本或图片（文本优先）以及相应的响应事件，就可以实现想要的效果 效果图","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://yongqianvip.github.io/tags/React-Native/"}],"keywords":[]},{"title":"React-Native中处理ListView的上拉加载更多","slug":"RN-ListViewLoadMore","date":"2016-07-31T07:07:25.000Z","updated":"2016-09-13T08:23:53.000Z","comments":true,"path":"2016/07/31/RN-ListViewLoadMore/","link":"","permalink":"http://yongqianvip.github.io/2016/07/31/RN-ListViewLoadMore/","excerpt":"ReactNative(RN)中的ListView是一个非常常用的组件，RN中已经有了现成的RefreshControl，官方文档中有具体用法，这里主要记录一下我是如何做上拉加载更多的示例中的数据来源于阿里巴巴网站 https://m.alibaba.com/products/tool_boxes/2.html?XPJAX=1 https://m.alibaba.com/products/tool_boxes/3.html?XPJAX=1 https://m.alibaba.com/products/tool_boxes/4.html?XPJAX=1 因为没有涉及原生部分代码，且RN组件也是通用的，所以理论上是兼容iOS和Android的","text":"ReactNative(RN)中的ListView是一个非常常用的组件，RN中已经有了现成的RefreshControl，官方文档中有具体用法，这里主要记录一下我是如何做上拉加载更多的示例中的数据来源于阿里巴巴网站 https://m.alibaba.com/products/tool_boxes/2.html?XPJAX=1 https://m.alibaba.com/products/tool_boxes/3.html?XPJAX=1 https://m.alibaba.com/products/tool_boxes/4.html?XPJAX=1 因为没有涉及原生部分代码，且RN组件也是通用的，所以理论上是兼容iOS和Android的工程源码在这里 目录结构如图： 熟悉Redux 的对这个结构肯定不陌生，为了尽可能的简单，工程中只保留了单个Action(product.js)和单个Reducer(rootReducer.js) 一定要把控好各种状态 不管是下拉刷新，还是加载更多，都要有一个对应的状态来控制，以便于加锁，防止重复操作 如果isLoadingMore为true，不能再响应LoadMoreData方法 LoadMoreData结束（成功或失败）后将isLoadingMore置为false 关键方法 onEndReachedListView在滚动到最后一个Cell的时候，会触发onEndReached方法，就是从这个方法入手，在ProductList.js中， let _pageNo = 2; const _pageSize = 30; export defaultclass ProductList extends Component { ... _toEnd() { const { reducer } = this.props; //ListView滚动到底部，根据是否正在加载更多 是否正在刷新 是否已加载全部来判断是否执行加载更多 if (reducer.isLoadingMore || reducer.products.length &gt;= reducer.totalProductCount || reducer.isRefreshing) { return; }; InteractionManager.runAfterInteractions(() =&gt; { console.log(&quot;触发加载更多 toEnd() --&gt; &quot;); this._loadMoreData(); }); } _loadMoreData() { const { reducer, dispatch } = this.props; dispatch(changeProductListLoadingMore(true)); _pageNo = Number.parseInt(reducer.products.length / _pageSize) + 1; dispatch(getProductList(_pageNo)); } _renderFooter() { const { reducer } = this.props; //通过当前product数量和刷新状态（是否正在下拉刷新）来判断footer的显示 if (reducer.products.length &lt; 1 || reducer.isRefreshing) { return null }; if (reducer.products.length &lt; reducer.totalProductCount) { //还有更多，默认显示‘正在加载更多...’ return &lt;LoadMoreFooter /&gt; }else{ // 加载全部 return &lt;LoadMoreFooter isLoadAll={true}/&gt; } } render() { const { reducer } = this.props; const ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&gt; r1 !== r2}); return ( &lt;ListView style={ styles.listViewContent } dataSource={ ds.cloneWithRows(reducer.products) } renderRow={ this._renderRow.bind(this) } onEndReached={ this._toEnd.bind(this) } onEndReachedThreshold={10} renderFooter={ this._renderFooter.bind(this) } enableEmptySections={true} refreshControl={ &lt;RefreshControl refreshing={ reducer.isRefreshing } onRefresh={ this._onRefresh.bind(this) } tintColor=&quot;gray&quot; colors={[&apos;#ff0000&apos;, &apos;#00ff00&apos;, &apos;#0000ff&apos;]} progressBackgroundColor=&quot;gray&quot;/&gt; }/&gt; ) } ... } 加载更多组件LoadMoreFooter import React, { Component } from &apos;react&apos;; import { View, Text, StyleSheet, } from &apos;react-native&apos;; class LoadMoreFooter extends Component { constructor(props) { super(props); } render() { return ( &lt;View style={styles.footer}&gt; &lt;Text style={styles.footerTitle}&gt;{this.props.isLoadAll ? &apos;已加载全部&apos; : &apos;正在加载更多……&apos;}&lt;/Text&gt; &lt;/View&gt; ) } } const styles = StyleSheet.create({ footer: { flexDirection: &apos;row&apos;, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, height: 40, }, footerTitle: { marginLeft: 10, fontSize: 15, color: &apos;gray&apos; } }) export default LoadMoreFooter","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://yongqianvip.github.io/tags/React-Native/"}],"keywords":[]},{"title":"你的App几秒钟完成启动？","slug":"LaunchTime","date":"2016-05-01T07:07:25.000Z","updated":"2016-09-14T07:52:19.000Z","comments":true,"path":"2016/05/01/LaunchTime/","link":"","permalink":"http://yongqianvip.github.io/2016/05/01/LaunchTime/","excerpt":"通过简单的一段代码统计应用启动时间","text":"通过简单的一段代码统计应用启动时间 在main.m中 12345678910#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;CFAbsoluteTime StartTime;int main(int argc, char * argv[]) &#123; StartTime = CFAbsoluteTimeGetCurrent(); NSLog(@&quot;开始启动----&gt;%f&quot;,StartTime); ...&#125; 在AppDelegate.m中 #import &quot;AppDelegate.h&quot; CFAbsoluteTime StartTime; @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@&quot;完成启动----&gt;%f&quot;, CFAbsoluteTimeGetCurrent()); NSLog(@&quot;启动用时----&gt;%f&quot;,CFAbsoluteTimeGetCurrent()-StartTime); }); ... } CMD + R，程序运行起来启动时间会第一时间打印出来 原理解释： 这个dispatch_async中提交的工作会在app主线程启动后的下一个run lopp中运行，此时app已经完成了载入并且将要显示第一帧画面，也就是系统会运行到-[UIApplication _reportAppLaunchFinished]之前 阅读原文","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yongqianvip.github.io/tags/iOS/"}],"keywords":[]},{"title":"初识Markdown","slug":"learnMarkdown","date":"2015-12-10T07:07:25.000Z","updated":"2016-09-13T08:28:59.000Z","comments":true,"path":"2015/12/10/learnMarkdown/","link":"","permalink":"http://yongqianvip.github.io/2015/12/10/learnMarkdown/","excerpt":"什么是Markdown?Markdown 是一种轻量级的 标记语言，已经成为一种适用于网络的书写语言。目前已经有很多网站开始支持Markdown文字录入，比如简书， CSDN博客， 我比较喜欢Markdown的优点是它可以导出html格式的文件在网站上发布，可以导出pdf格式文件，甚至你可以用它来写简历…… Markdown虽说算是一门语言，但它的语法真的很简单，常用的也不过十多种，很容易上手，而且一旦熟悉了它的语法，你会发现网络写作原来这么随意.","text":"什么是Markdown?Markdown 是一种轻量级的 标记语言，已经成为一种适用于网络的书写语言。目前已经有很多网站开始支持Markdown文字录入，比如简书， CSDN博客， 我比较喜欢Markdown的优点是它可以导出html格式的文件在网站上发布，可以导出pdf格式文件，甚至你可以用它来写简历…… Markdown虽说算是一门语言，但它的语法真的很简单，常用的也不过十多种，很容易上手，而且一旦熟悉了它的语法，你会发现网络写作原来这么随意. Markdown怎么用?以下就常用的几点做简要说明，仅供小白用户参考， 大神请绕行…… 标题 设置标题很简单，你只需要在你要设置为标题的文本前加 “#”即可，一级标题”#”，二级标题”##”… 最多支持六级标题”######” 代码 添加内嵌代码可以使用一对回勾号” ` “ 包裹一段内嵌代码 如这是内嵌代码 对于插入代码， 标准Markdown基于缩进代码行或者4个空格位;这让你不用关心代码用的什么语言就可以以较好的格式展示你的代码，缺点是没有代码高亮 列表 列表分有序列表和无序列表，写法也相当简单 加粗 和 斜体 **字体加粗** —&gt; 字体加粗 * 斜体 * –&gt; 斜体 外链 格式: [title](http://) 例如 [点击查看张北草原的照片](http://yongqian.sinaapp.com/blog/img/151202/caoyuan.jpeg) 点击查看张北草原的照片 图片 图片跟外链格式类似 不过前边多了一个! 格式: ![alt](http://) 例如 ![张北草原的照片](http://yongqian.sinaapp.com/blog/img/151202/caoyuan.jpeg) 引用 使用 &gt; 开头 表示引用 这是引用部分 引用了某位大神的文章 感谢这位大神 向大神致敬 脚注 在正文中，如果参考了某些资料或想要单独对某一词语做解释可以添加脚注 例如 什么是Markdown[^1]，Markdown就是一门语言[^2] 什么是Markdown^1，Markdown就是一门语言^2 与此同时在文章末尾注明脚注内容 `[^1]: Markdown就是一门语言` `[^2]: 语言指的是语法` 表格 之所以把表格放在最后边，是因为我觉得用Markdown写表格太DD疼了 注意:冒号决定表格中内容水平对齐方式 | 姓名 | 年龄 | 身高 | 体重 | --- | :---: | :-- | --: | 默认左对齐 | 冒号在两端 | 冒号在左 | 冒号在右 | ZDD | 18 | 170 | 50 | YYQ | 19 | 180 | 80 姓名 年龄 身高 体重 默认左对齐 居中对齐 左对齐 右对齐 ZDD 18 17000000 500000 YYQ 19 180 80 Markdown编辑器 Mac OS Mou MacDown? Windows 没用过没有发言权， 请自行Baidu或Google ^_^","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yongqianvip.github.io/tags/Markdown/"}],"keywords":[]},{"title":"创建podspec文件，为自己的项目添加pod支持","slug":"creatPodspec","date":"2015-12-02T07:07:25.000Z","updated":"2016-09-13T08:30:31.000Z","comments":true,"path":"2015/12/02/creatPodspec/","link":"","permalink":"http://yongqianvip.github.io/2015/12/02/creatPodspec/","excerpt":"","text":"开篇扯淡作为一个iOS开发者，一定用过CocoaPods吧，没用过?点这儿去面壁吧 Cocoapods作为iOS开发的包管理器，给我们的开发带来了极大的便利，而且越来越多的第三方类库支持Pod，可以通过Pod傻瓜式的集成到自己的工程中，那么问题来了，我自己也有一系列的小工具类，怎么让它也支持pod集成进而让其他朋友方便的使用呢? 刚好，最近项目不算紧，自己尝试着弄了一下，在这里记录一下尝试的过程， 一来备忘， 二来共享…… 其实网上这种文章数不胜数，但是不一定都是适合自己的，比如接下来写的东西我觉得都是适用于我的，但未必能适用于正在阅读此文的你，又或者下文中有一部内容能够帮到你，如果真是这样，我也很高兴 本文有诸多不完善的地方，以后时间充足在慢慢完善吧 写的不好 砖下留情 开始我这里拿一个小demo做示例，目的是把工程中的一些category提取出来支持 pod 1.上传项目源码把项目源码上传到gitHub仓库再clone到本地(以iOS_Category为例–源码在这里 )， 如果项目本来就在gitHub的仓库中， 直接clone到本地即可 2.创建项目的podspec文件 用终端命令cd到本地项目目录并执行如下命令: $ pod spec create iOS_Category 这时候本地就生成一个iOS_Category.podspec文件 用编辑器打开.podspec文件 (我自己用Sublime Text) 删除不必要的注释(这里只简单介绍基本用法，所以只用到一部分必须得字段 更多字段请移步http://guides.cocoapods.org/syntax/podspec.html) Pod::Spec.new do |s| s.name = &quot;iOS_Category&quot; s.version = &quot;0.0.1&quot; s.summary = &quot;all kinds of categories for iOS develop&quot; s.description = &lt;&lt;-DESC this project provide all kinds of categories for iOS developer DESC s.homepage = &quot;https://github.com/yongqianvip/iOS_Category&quot; s.license = &quot;MIT&quot; s.license = { :type =&gt; &quot;MIT&quot;， :file =&gt; &quot;LICENSE&quot; } s.author = { &quot;yongqianvip&quot; =&gt; &quot;yongqianvip@163.com&quot; } s.platform = :ios s.source = { :git =&gt; &quot;https://github.com/yongqianvip/iOS_Category.git&quot;， :tag =&gt; &quot;0.0.1&quot; } s.source_files = &quot;Classes&quot;， &quot;iOS_Category/Classes/**/*.{h，m}&quot; s.exclude_files = &quot;Classes/Exclude&quot; s.public_header_files = &quot;iOS_Category/Classes/UIKit/UI_Categories.h&quot;，&quot;iOS_Category/Classes/Foundation/Foundation_Category.h&quot;，&quot;iOS_Category/Classes/**/*.h&quot; s.requires_arc = true end 验证podspec文件 编辑完podspec文件后需要验证一下这个文件是否可用podspec文件不允许有任何的Warning或者Error 执行命令 $ pod lib lint 如果出现 -&gt; iOS_Category (0.0.1) iOS_Category passed validation. 则说明验证通过， 否则， 根据提示修改podspec文件再次验证直到验证通过 附带说一下，Xcode允许警告存在，所以可以通过命令屏蔽警告 $ pod lib lint --allow-warnings 如果出现Error但是提示信息不足，可以添加--verbose 以获取更多错误信息 $ pod lib lint --verbose 3.打tag 上传podspecpodspec文件中需要指定的tag， 完成上述操作后给项目打tag $ git tag -m&quot;first release iOS_Category with podspec&quot; &quot;0.0.1&quot; $ git push --tags 最后使用pod trunk命令，把podspec文件推送到CocoaPod官方库 pod trunk 需要注册 具体做法这里不再赘述 请移步CocoaPod官网 pod trunk 设置完毕后执行命令 $ pod trunk push iOS_Category.podspec 这个过程可能会比较耗时，原因你懂的(实在很慢等不及的话，请自备梯子) 4.最后如果一切顺利 pod search iOS_Category 就可以找到刚才的项目了 并且还有安装命令&lt; pod ‘iOS_Category’，’~&gt;0.0.1’ &gt;","categories":[],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://yongqianvip.github.io/tags/CocoaPods/"}],"keywords":[]},{"title":"Gulp 自动任务管理工具","slug":"gulpReadme","date":"2015-12-01T07:07:25.000Z","updated":"2016-09-13T08:33:54.000Z","comments":true,"path":"2015/12/01/gulpReadme/","link":"","permalink":"http://yongqianvip.github.io/2015/12/01/gulpReadme/","excerpt":"Gulp需要全局安装，然后再在项目的开发目录中安装为本地模块。先进入项目目录，运行下面的命令。 $ npm install -g gulp $ npm install --save-dev gulp","text":"Gulp需要全局安装，然后再在项目的开发目录中安装为本地模块。先进入项目目录，运行下面的命令。 $ npm install -g gulp $ npm install --save-dev gulp 除了安装gulp以外，不同的任务还需要安装不同的gulp插件模块。举个例子，下面代码安装了gulp-uglify模块。 $ npm install --save-dev gulp-uglify * gulpfile.js 项目根目录中的gulpfile.js，是Gulp的配置文件。下面就是一个典型的gulpfile.js文件。 var gulp = require(&apos;gulp&apos;); var uglify = require(&apos;gulp-uglify&apos;); gulp.task(&apos;minify&apos;, function () { gulp.src(&apos;myJs/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;build_min&apos;)) }); 上面代码中，gulpfile.js加载gulp和gulp-uglify模块之后，使用gulp模块的task方法指定任务minify。task方法有两个参数，第一个是任务名，第二个是任务函数。在任务函数中，使用gulp模块的src方法，指定所要处理的文件，然后使用pipe方法，将上一步的输出转为当前的输入，进行链式处理。 task方法的回调函数使用了两次pipe方法，也就是说做了两种处理。第一种处理是使用gulp-uglify模块，压缩源码；第二种处理是使用gulp模块的dest方法，将上一步的输出写入本地文件，这里是build.js（代码中省略了后缀名js）。 执行minify任务时，就在项目目录中执行下面命令就可以了。 $ gulp minify “从上面的例子中可以看到，gulp充分使用了“管道”思想，就是一个数据流（stream）：src方法读入文件产生数据流，dest方法将数据流写入文件，中间是一些中间步骤，每一步都对数据流进行一些处理。” 下面是另一个数据流的例子。 gulp.task(&apos;js&apos;, function () { return gulp.src(&apos;js/*.js&apos;) .pipe(jshint()) .pipe(uglify()) .pipe(concat(&apos;app.js&apos;)) .pipe(gulp.dest(&apos;build&apos;)); }); gulp.task(&apos;printHello&apos;,[&apos;minify&apos;], function () { for (var i = 10 - 1; i &gt;= 0; i--) { console.log(&apos;Hello world!&apos; + i); }; }); gulp.task(&apos;watch&apos;, function () { gulp.watch(&apos;myJs/*.js&apos;, [&apos;printHello&apos;,&apos;minify&apos;]); }); #####默认任务 gulp.task(&apos;default&apos;,[&apos;watch&apos;]); 未完待续…….","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yongqianvip.github.io/tags/gulp/"}],"keywords":[]},{"title":"谓词 NSPredicate","slug":"aboutNSPredicate","date":"2015-11-05T07:07:25.000Z","updated":"2016-09-14T07:54:29.000Z","comments":true,"path":"2015/11/05/aboutNSPredicate/","link":"","permalink":"http://yongqianvip.github.io/2015/11/05/aboutNSPredicate/","excerpt":"NSPredicate：谓词 字面翻译是这个意思，但是我觉得谓词这个词太难以理解了NSPredicate的具体用途应该还是过滤，类似于过滤条件之类的，相当于一个主语的谓语，所以说会是谓词这个名字。（我是这么理解的）","text":"NSPredicate：谓词 字面翻译是这个意思，但是我觉得谓词这个词太难以理解了NSPredicate的具体用途应该还是过滤，类似于过滤条件之类的，相当于一个主语的谓语，所以说会是谓词这个名字。（我是这么理解的） 原文在这里(http://blog.csdn.net/lmf208/article/details/38345321) NSPredicate的创建我们看到创建谓词使用类方法 predicateWithFormat: (NSString *)format format 里的东西真的和SQL的where条件差不多。另外，参数format 与NSLog 的格式化模版差不多，如果 1 和188.0 是传递过来的参数，你可以写成如下的形式： @&quot;pid&gt;%d and height&lt;%f&quot;,1,188.0 NSPredicate中主要的几种运算方式 1.比较运算符 &gt; 、&lt; 、== 、 &gt;= 、&lt;= 、 !=例：@&quot;number &gt;= 99&quot; 2.逻辑运算符：AND、OR、NOT 这几个运算符计算并、或、非的结果。 3.范围运算符：IN 、BETWEEN例： @&quot;number BETWEEN {1,5}&quot; @&quot;address IN {&apos;shanghai&apos;,&apos;nanjing&apos;}&quot; 4.字符串本身:SELF 例： @&quot;SELF == &apos;APPLE&apos;&quot; 5.字符串相关：BEGINSWITH、ENDSWITH、CONTAINS例： @&quot;name CONTAIN[cd] &apos;ang&apos;&quot; //包含某个字符串 @&quot;name BEGINSWITH[c] &apos;sh&apos;&quot; //以某个字符串开头 @&quot;name ENDSWITH[d] &apos;ang&apos;&quot; //以某个字符串结束 注:`[c]`不区分大小写 , `[d]`不区分发音符号即没有重音符号 , `[cd]`既不区分大小写，也不区分发音符号。 6.通配符：LIKE例： @&quot;name LIKE[cd] &apos;*er*&apos;&quot; // * 代表通配符,Like也接[cd]. @&quot;name LIKE[cd] &apos;???er*&apos;&quot;` 7.正则表达式：MATCHES例： NSString *regex = @&quot;^A.+e$&quot;; //以A开头，e结尾 @&quot;name MATCHES %@&quot;,regex 如何使用NSPredicate对一个自定义实体进行筛选NSPredicate我暂时都是用于过滤的，否则我们过滤就需要自己写判断 写循环，去判断输出了。接下来就上代码和例子吧。建立一个实体类Dog @property (copy , nonatomic) NSString* name; @property (assign , nonatomic) int age ; //这样我们就有一个类了 //我们创建 5只Dog的实体 Dog * dog1=[Dog news]; dog1.name=@&quot;这是第一只Dog&quot;;dog1.age=@&quot;11&quot;; Dog * dog2=[Dog news]; dog2.name=@&quot;这是第二只Dog&quot;; dog2.age=@&quot;22&quot;; Dog * dog3=[Dog news]; dog3.name=@&quot;这是第三只Dog&quot;; dog3.age=@&quot;33&quot;; Dog * dog4=[Dog news]; dog4.name=@&quot;这是第四只Dog&quot;; dog4.age=@&quot;44&quot;; Dog * dog5=[Dog news]; dog5.name=@&quot;这是第五只Dog&quot;; dog5.age=@&quot;55&quot;; 不要吐槽我的Dogs的年龄 → 。→然后我们需要一个Array把他们都装进去 NSArray * dogArr=@[dog1,dog2,dog3,dog4,dog5]; 酱紫所有的Dog都装到一个数组里了使用NSPredicate的筛选没有使用NSPredicate的筛选应该大家都会写，循环+判断。。。使用NSPredicate的筛选具体使用的代码 //创建谓词的对象 谓词条件是基于KVC的，所以需要说明一点，加入Dog里面有个属性是Doginfo指向Doginfo类， //在使用的时候 我们的条件就要写成Doginfo.xxx了。 NSPredicate* predicate = [NSPredicate predicateWithFormat:@&quot;name==&apos;这是第一只Dog&apos; AND age ==11&quot;]; for(Dog * d in dogArr) { if([predicate evaluateWithObject:d]) { NSLog(d.name); } } 以上的代码打印出来的结果就是 这是第一只Dog NSPredicate筛选一个对象逻辑还是很清晰的，不过这里比较麻烦的就是 还有一个循环，这里我们会发现数组提供了一个方法可以更方便的检索数组对象直接筛选出一个符合谓词的新数组。 NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;age &gt;11&quot;]; NSMutableArray *arrayPre=[dogArr filteredArrayUsingPredicate: pre]; arrayPre里面的对象就会是 除了dog1之外的所有的dog。（至于为什么看我的条件…） 看到这里发现NSPredicate 可以用于自定义的实体的检索、筛选，那如果用于 NSString，NSInteger，bool呢？那我们再看一段代码吧 NSArray *arrays=[NSArray arrayWithObjects: @&quot;Apple&quot;, @&quot;Google&quot;, @&quot;MircoSoft&quot;, nil]; NSPredicate *pre2 = [NSPredicate predicateWithFormat:@&quot;SELF==&apos;Apple&apos;&quot;]; 上面这段代码是匹配字符串的时候 NSPredicate 需要如何声明使用NSPredicate在两个数组之间进行差异筛选 NSArray* array = @[@&quot;aa&quot;,@&quot;bb&quot;]; NSArray* array2 = @[@&quot;aa&quot;,@&quot;bb&quot;,@&quot;cc&quot;,@&quot;dd&quot;]; NSPredicate* thePredicate = [NSPredicate predicateWithFormat:@&quot;NOT(SELF in %@)&quot;,array]; NSArray* arr3 = [array2 filteredArrayUsingPredicate:thePredicate]; NSLog(@&quot;%@&quot;,arr3); 上面的代码输出结果 arr3={@&quot;cc&quot; ,@&quot;dd&quot;} 这样大家就很容易理解了SELF在前面有介绍过 可以往回翻阅一下如何使用正则筛选一个数组 NSString *regex = @&quot;^A.+e$&quot;;//以A 开头，以e 结尾的字符。 NSPredicate *pre= [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex]; if([pre evaluateWithObject: @&quot;Apple&quot;]){ printf(&quot;YES\\n&quot;); }else{ printf(&quot;NO\\n&quot;); } 关于NSPredicate的其他说明和注意事项，以及技巧动态属性名假如你的代码如下 NSPredicate *p = [NSPredicate predicateWithFormat:@&quot;name = %@&quot;, @&quot;name1&quot;]; 显然代码没有任何问题，但是这个不是最好的写法, 我建议如下写法： NSPredicate *preTemplate = [NSPredicate predicateWithFormat:@&quot;name==$NAME&quot;]; NSDictionary *dic=[NSDictionary dictionaryWithObjectsAndKeys: @&quot;name1&quot;, @&quot;NAME&quot;,nil]; NSPredicate *pre=[preTemplate predicateWithSubstitutionVariables: dic]; 这样看上去可能会让代码逻辑更清晰。当过滤条件字段都是动态的时候 NSString *key = @&quot;name&quot;; NSString *value = @&quot;name1&quot;; NSPredicate *p = [NSPredicate predicateWithFormat:@&quot;%@ = %@&quot;, key, value]; 然后当你执行到第三行的时候代码就会报错！逻辑上没错误啊！！！为什么会出错呢？NSPredicate要自动添加引号，所以最后得到的格式应该是 @&quot;&apos;name&apos; = &apos;name1&apos;&quot;。 明显不对。要做的就是: NSPredicate *p = [NSPredicate predicateWithFormat:@&quot;%K = %@&quot;, key, value]; 总结NSPredicate 的简单的使用就介绍到这里，这里有些都是从网络上其他人的额博客转过来的内容，我自己加以修改和一些自己的理解。希望可以帮到大家。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yongqianvip.github.io/tags/iOS/"}],"keywords":[]},{"title":"iOS中加载Gif图的正确姿势","slug":"iOS_loadGif","date":"2015-08-18T07:07:25.000Z","updated":"2016-09-13T08:37:37.000Z","comments":true,"path":"2015/08/18/iOS_loadGif/","link":"","permalink":"http://yongqianvip.github.io/2015/08/18/iOS_loadGif/","excerpt":"昨天无意中看到一个帖子，写如何加载gif图的，感觉好麻烦的样子，本来很简单的一件事，为什么搞的这么复杂呢？","text":"昨天无意中看到一个帖子，写如何加载gif图的，感觉好麻烦的样子，本来很简单的一件事，为什么搞的这么复杂呢？的确，App上有的地方能够显示一些动态图（gif图）那对用户体验来说可是极好的，绝对是App的加分亮点，逼格立马上了好几个台阶 But 我们都知道iOS中显示图片的控件是UIImageView，但是UIImageView不支持.gif格式的图片，那么怎么才能正确的加载一个gif图呢？ 其实，仔细想想，除了UIImageView可以加载图片之外，就没有别的系统控件了么？仔细想想，当然有！！ UIWebView 用WebViewUIWebView有这么一个方法： - (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL; data就是要加载的二进制数据（NSData），我们要加载gif图，就需要先把图片转换成NSData类型 MIME(Multipurpose Internet Mail Extensions)^1多用途互联网邮件扩展类型。在MIME 参考手册中我们可以查到，我们需要的类型是image/gif 编码格式 UTF-8 Url这里就不需要了 那么借助UIWebView的这个方法就可以加载gif格式的图片了，基本思路就是： 创建一个类（GifImageView）继承自UIView，在GifImageView中创建一个UIWebView加载gif图，这样一来，加载gif就像加载一个UIView那么easy了 代码 GifImageView.h #import &lt;UIKit/UIKit.h&gt; @interface GifImageView : UIView - (id)initWithFrame:(CGRect)frame GifImageName:(NSString*)gitImageName; @end GifImageView.m #import &quot;GifImageView.h&quot; @implementation GifImageView - (id)initWithFrame:(CGRect)frame GifImageName:(NSString*)gitImageName{ self = [super initWithFrame:frame]; if (self) { self.backgroundColor = [UIColor clearColor]; UIView *placeholdView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 1, 1)]; [self addSubview:placeholdView]; NSData *gifData = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:gitImageName ofType:@&quot;gif&quot;]]; UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, frame.size.height)]; [webView setScalesPageToFit: YES]; [webView setBackgroundColor: [UIColor clearColor]]; [webView setOpaque: 0]; [self addSubview:webView]; [webView loadData:gifData MIMEType:@&quot;image/gif&quot; textEncodingName:@&quot;&quot; baseURL:[NSURL URLWithString:@&quot;&quot;]]; [webView setUserInteractionEnabled:NO]; } return self; } 使用 ... #import &quot;GifImageView.h&quot; ... GifImageView *gifView = [[GifImageView alloc] initWithFrame:CGRectMake(50, 270, 175, 105) GifImageName:@&quot;gifImage&quot;]; [self.view addSubview:gifView]; ... 代码语义明确我就不再写注释了 比较关键的是关闭了webView的交互，防止触发滚动，长按等事件，但这不影响其父视图的交互 移除 它就是一个View，如果你想移除它，就用你的洪荒之力吧 写在最后使用这个方案我自己有一个顾虑，就是用的多了会不会有一些问题，比如性能问题 有gif图，能给一个App添彩不少，但是我到目前为止还没有发现哪一个App中有大量的gif图展示的，一般项目中不会有大量的gif图存在（一些主要目的就是展示gif图的App除外），我自己的项目中也只是个别地方用到，所以不能确定对大量使用这种方案会出现哪些问题。。。 当然，这肯定不是唯一的方案，也不一定是最好的方案如果你觉得这个方案有不妥的地方，欢迎留言指正如果你有更好的方案，也欢迎留言共同学习","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yongqianvip.github.io/tags/iOS/"}],"keywords":[]},{"title":"UIAlertView 和 UIAlertViewController之间的抉择","slug":"uialertviewcontroller_base","date":"2015-05-10T07:07:25.000Z","updated":"2016-09-13T08:38:06.000Z","comments":true,"path":"2015/05/10/uialertviewcontroller_base/","link":"","permalink":"http://yongqianvip.github.io/2015/05/10/uialertviewcontroller_base/","excerpt":"iOS8之后UIAlertViewController的出现让我们不得不考虑在iOS7上的兼容问题 其实无非是做一下判断iOS8之前仍然用UIAlertView 之后用UIAlertViewController","text":"iOS8之后UIAlertViewController的出现让我们不得不考虑在iOS7上的兼容问题 其实无非是做一下判断iOS8之前仍然用UIAlertView 之后用UIAlertViewController 关于UIAlertViewController看源码 首先要说的是UIAlertControllerStyle这一属性 在头文件中 typedef NS_ENUM(NSInteger, UIAlertControllerStyle) { UIAlertControllerStyleActionSheet = 0, UIAlertControllerStyleAlert } NS_ENUM_AVAILABLE_IOS(8_0); 这么一来，UIAlertController就等于是UIAlertView和UIActionSheet的合体了，只需要设置不同的style就可任意的切换要AlertView还是ActionSheet了（ActionSheet这里先不说，这里主要说说UIAlertController替代UIAlertView的用法）。 其次是继承关系 · NS_CLASS_AVAILABLE_IOS(8_0) @interface UIAlertController : UIViewController UIAlertController继承自UIViewController，那么注定它的用法和继承自UIView的UIAlertView和UIActionSheet不同，addSubView:的方法肯定是不能用了，在一个controller中想要呈现另一个controller，我首先想到的是模态 - (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0); 了解以上的基本信息，就可以开始尝试使用了 如何使用//初始化 UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;温馨提示&quot; message:@&quot;您正在使用 UIAlertController&quot; preferredStyle:UIAlertControllerStyleAlert]; //创建action 添加到alertController上 可根据UIAlertActionStyleDefault创建不通的alertAction UIAlertAction *action1 = [UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) { //回调 // 模态视图，使用dismiss 隐藏 [alertController dismissViewControllerAnimated:YES completion:nil]; }]; UIAlertAction *action2 = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancle handler:^(UIAlertAction *action) { [alertController dismissViewControllerAnimated:YES completion:nil]; }]; //往alertViewController上添加alertAction [alertController addAction:action1]; [alertController addAction:action2]; //呈现 [self presentViewController:alertController animated:YES completion:nil]; 这里需要提一下UIAlertAction，它是随UIAlertViewController一起出现的，它的用法也很简单，看头文件就行了，不再赘述，但需要特别说明的是，UIAlertAction通过block回调使alert相关的代码变得紧凑，明了，不再像UIAlertView使用delegate把相关代码拆散。 补充其实从上边可以看出使用UIAlertViewController是非常简单的，无非用的时候做一下兼容处理，为什么我还要写这么一段？因为有人懒。。。。 这里有一个工具类，做好了iOS8之前和之后的兼容 拿走不谢https://github.com/yongqianvip/iOS_DevTool","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yongqianvip.github.io/tags/iOS/"}],"keywords":[]},{"title":"<<重构是改革,重写是革命>>","slug":"RecreatRebuild","date":"2015-03-15T07:07:25.000Z","updated":"2016-09-13T07:34:19.000Z","comments":true,"path":"2015/03/15/RecreatRebuild/","link":"","permalink":"http://yongqianvip.github.io/2015/03/15/RecreatRebuild/","excerpt":"","text":"如果将一个软件系统或项目比喻成一个国家，那么重构就好比是改革，推翻老的系统，重写一个新系统就好比是革命。重构就是戊戌变法，重写就是辛亥革命。革命总是比改革要付出更多的代价，因为革命是要流血的。重写一个系统也是如此，要付出比重构更大的代价，因为原有的代码基本上全抛弃，公司曾经为那些编写老系统代码的程序员支付的工资就全付之东流了。但是，国内大部分软件公司仍然每隔三四年就上演一次这样的悲剧。究其原因，乃是不知道用重构这样小的代价去改善既有代码的设计。即便听说过重构，但却对重构的技巧、本质和意义一知半解，结果往往打着重构的旗帜，却做着重写的工作。 重构是每天都应该做的工作。那些说“等我们n.X版本发布以后，有时间了，我们好好重构一下整个系统，这个系统中的代码太乱了”，这不是重构。既然知道代码乱，有坏味道了，就应该立即着手重构。 重写往往是从来不重构造成的，代码越来越臃肿、冗余、混乱、腐朽，设计上发现的漏洞越来越多，实在无法在原有系统上维护和扩充代码了。于是开始所谓“重构”，却发现无从下手，无法完成，只好重写。这好比一个朝代无法延续了，于是来一场起义，建立一个新王朝，时间长了，又陷入腐朽，又被推翻，周而复始。人事间的事往往都如此，新系统写好后，三五年后又是推到重写。 为什么从来不重构呢？国内的公司很多还处于瀑布开发模式的思维中，认为设计阶段完成后是编码阶段，编码阶段是不能修改设计的。目前先进的软件工程思想如敏捷开发都是迭代开发模式，设计是在多次迭代的过程中逐步完善的。尤其是XP编程，完全没有设计阶段的概念，这对很多国内的软件开发者是个革命性的思想。 事实上，国内的软件设计者大多从业时间不长，工作两三年就敢做一些复杂系统的架构设计，经验、技术和能力的不足导致他们的设计往往是拙劣、丑陋和低效的，漏洞百出。瀑布开发模式往往有形无实，到测试和维护阶段总是能发现设计上致命的问题。这时要去改正这些设计错误，需要修改代码。但代码往往是混乱和低质量的，查错困难，修改的难度非常大。大部分项目经理往往是采取一种治标不治本的办法解决问题，而不去惊动原有的设计。最后导致设计的问题积累得越来越多，直到所有的人都无法忍受了，就重写。 这其中涉及到编码过程中的质量控制和代码评审的问题，大部分软件公司都没有代码评审，也没有别的代码质量控制的办法。其次，如果代码质量还可以忍受，因担心重构后不能保证原有的功能和特性而不敢重构，这就涉及到敏捷开发原则中提到的一个原则：勇气！大多数程序员似乎都缺乏这个特质——勇气，是的，改变的勇气。虽然勇气不是个技术问题，但没有勇气，重构也是无法完成的。 做什么事情都需要勇气，不仅仅是开发软件！","categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"http://yongqianvip.github.io/tags/经验/"}],"keywords":[]},{"title":"UITableView去掉headerView和footerView的粘性,随tableview滚动(有瑕疵)","slug":"tableViewHeaderFooterView","date":"2015-02-15T07:07:25.000Z","updated":"2016-09-13T07:34:19.000Z","comments":true,"path":"2015/02/15/tableViewHeaderFooterView/","link":"","permalink":"http://yongqianvip.github.io/2015/02/15/tableViewHeaderFooterView/","excerpt":"","text":"-(void)scrollViewDidScroll:(UIScrollView *)scrollView { if (scrollView.tag == 100102) { UITableView *tableview = (UITableView *)scrollView; CGFloat sectionHeaderHeight = 20; CGFloat sectionFooterHeight = 20; CGFloat offsetY = tableview.contentOffset.y; if (offsetY &gt;= 0 &amp;&amp; offsetY &lt;= sectionHeaderHeight) { tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionFooterHeight, 0); }else if (offsetY &gt;= sectionHeaderHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight) { tableview.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, -sectionFooterHeight, 0); }else if (offsetY &gt;= tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height) { tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -(tableview.contentSize.height - tableview.frame.size.height - sectionFooterHeight), 0); } } } 缺点:这个方法目前只适用于headerView和footerView的高度都是固定值的情况,另外在滚动到最后一个footerView即将显示的时候,滚动条变化有点儿突然","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yongqianvip.github.io/tags/iOS/"}],"keywords":[]},{"title":"获取iOS设备的UDID","slug":"getUDID","date":"2014-11-13T07:07:25.000Z","updated":"2016-09-13T08:39:55.000Z","comments":true,"path":"2014/11/13/getUDID/","link":"","permalink":"http://yongqianvip.github.io/2014/11/13/getUDID/","excerpt":"UDIDUDID （即Unique Device Identifier）是一个由子母和数字组成的 40 个字符串的序号，用来区别包括 iPhones, iPads, 以及 iPod Touches等iOS设备，这些编码看起来是随机的，实际上是跟硬件设备特点相联系的。","text":"UDIDUDID （即Unique Device Identifier）是一个由子母和数字组成的 40 个字符串的序号，用来区别包括 iPhones, iPads, 以及 iPod Touches等iOS设备，这些编码看起来是随机的，实际上是跟硬件设备特点相联系的。 使用keyChain存储UUID替代UDID 导入Security.framework 创建工具类”JPKeyChain” JPKeychain.h// // JPKeychain.h // IFood517 // // Created by YYQ on 14/11/13. // Copyright (c) 2014年 YYQ. All rights reserved. // #import &lt;Foundation/Foundation.h&gt; #import &lt;Security/Security.h&gt; @interface JPKeychain : NSObject + (void)save:(NSString *)service data:(id)data; + (id)load:(NSString *)service; + (void)delete:(NSString *)service; @end JPKeychain.m// // JPKeychain.m // IFood517 // // Created by YYQ on 14/11/13. // Copyright (c) 2014年 YYQ. All rights reserved. // #import &quot;JPKeychain.h&quot; @implementation JPKeychain + (NSMutableDictionary *)getKeychainQuery:(NSString *)service { return [NSMutableDictionary dictionaryWithObjectsAndKeys: (id)kSecClassGenericPassword,(id)kSecClass, service, (id)kSecAttrService, service, (id)kSecAttrAccount, (id)kSecAttrAccessibleAfterFirstUnlock,(id)kSecAttrAccessible, nil]; } + (void)save:(NSString *)service data:(id)data { //Get search dictionary NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; //Delete old item before add new item SecItemDelete((CFDictionaryRef)keychainQuery); //Add new object to search dictionary(Attention:the data format) [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:data] forKey:(id)kSecValueData]; //Add item to keychain with the search dictionary SecItemAdd((CFDictionaryRef)keychainQuery, NULL); } + (id)load:(NSString *)service { id ret = nil; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; //Configure the search setting //Since in our simple case we are expecting only a single attribute to be returned (the password) we can set the attribute kSecReturnData to kCFBooleanTrue [keychainQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData]; [keychainQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit]; CFDataRef keyData = NULL; if (SecItemCopyMatching((CFDictionaryRef)keychainQuery, (CFTypeRef *)&amp;keyData) == noErr) { @try { ret = [NSKeyedUnarchiver unarchiveObjectWithData:(__bridge NSData *)keyData]; } @catch (NSException *e) { NSLog(@&quot;Unarchive of %@ failed: %@&quot;, service, e); } @finally { } } if (keyData) CFRelease(keyData); return ret; } + (void)delete:(NSString *)service { NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; SecItemDelete((CFDictionaryRef)keychainQuery); } @end 有了这个工具类，我们就可以在keyChain中存储一些关键数据，比如用户名，密码之类，那么我们同样也就可以把UUID存进去替代UDID了 使用#import &quot;CommonCrypto/CommonDigest.h&quot; #import &quot;JPKeychain.h&quot; NSString * const KEY_UDID_INSTEAD = @&quot;com.jpgk.app.udid.instead.test&quot;; #pragma mark - Keychain 获取UUID +(NSString *)getDeviceIDInKeychain { NSString *getUDIDInKeychain = (NSString *)[JPKeychain load:KEY_UDID_INSTEAD]; NSLog(@&quot;从keychain中获取到的 UDID_INSTEAD %@&quot;,getUDIDInKeychain); if (!getUDIDInKeychain ||[getUDIDInKeychain isEqualToString:@&quot;&quot;]||[getUDIDInKeychain isKindOfClass:[NSNull class]]) { CFUUIDRef puuid = CFUUIDCreate( nil ); CFStringRef uuidString = CFUUIDCreateString( nil, puuid ); NSString * result = (NSString *)CFBridgingRelease(CFStringCreateCopy( NULL, uuidString)); CFRelease(puuid); CFRelease(uuidString); [JPKeychain save:KEY_UDID_INSTEAD data:result]; getUDIDInKeychain = (NSString *)[JPKeychain load:KEY_UDID_INSTEAD]; } NSLog(@&quot;最终 ———— UDID_INSTEAD %@&quot;,getUDIDInKeychain); return getUDIDInKeychain; } #更新 ———— 代码已上传到Git，并支持Pod（点击这里查看源码 ） Pod接入： pod &apos;KeyChain-UDID&apos; pod install 在需要使用的类中 #import &lt;YYQKeyChain.h&gt; ... ... NSString *udid = [YYQKeyChain getUDIDWithUniqueKey:@&quot;com.comname.app.udid.instead&quot;]; NSLog(@&quot;udid from keyChain %@&quot;, udid);","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yongqianvip.github.io/tags/iOS/"}],"keywords":[]},{"title":"为Xcode添加Empty Application、category、protocol等模板","slug":"XcodeExtension","date":"2014-10-11T07:07:25.000Z","updated":"2016-09-13T08:40:33.000Z","comments":true,"path":"2014/10/11/XcodeExtension/","link":"","permalink":"http://yongqianvip.github.io/2014/10/11/XcodeExtension/","excerpt":"最近项目中需要新建一个工具类（category）又想起Xcode自从6.0开始就移除了Empty Application、category、protocol等模板，想要新建这些类型的文件或者工程需要费点儿劲，闲来再写一下，总有人需要。。。。。。","text":"最近项目中需要新建一个工具类（category）又想起Xcode自从6.0开始就移除了Empty Application、category、protocol等模板，想要新建这些类型的文件或者工程需要费点儿劲，闲来再写一下，总有人需要。。。。。。 1、下载需要的材料 （下载） 这里分别是新建Xcode空工程，类目，延展和协议文件的模板 2、在Finder中打开应用程序列表，选中Xcode如下图，显示包内容后，command + shift + G，在弹出的路径输入框中贴入下边的路径 Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project Templates/iOS/Application 3、把之前下载的材料，结合自己需求添加到Application文件夹中更改这个文件的时候需要权限，输一下密码就行了如下图 4、重启Xcode ———— 完 ————","categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://yongqianvip.github.io/tags/Xcode/"}],"keywords":[]},{"title":"UIWebView背景颜色的设置 webview加载html文本 禁用webview长按","slug":"uiwebview","date":"2014-04-03T07:07:25.000Z","updated":"2016-09-18T02:46:38.000Z","comments":true,"path":"2014/04/03/uiwebview/","link":"","permalink":"http://yongqianvip.github.io/2014/04/03/uiwebview/","excerpt":"UIWebView 添加透明效果 最近使用了UIWebView，发现当如下设置时 myWebView.backgroundColor = [UIColor clearColor]; 没有实现预期的透明效果后来加上 myWebView.opaque = NO; myWebView.backgroundColor = [UIColor clearColor]; OK! 透明效果有了","text":"UIWebView 添加透明效果 最近使用了UIWebView，发现当如下设置时 myWebView.backgroundColor = [UIColor clearColor]; 没有实现预期的透明效果后来加上 myWebView.opaque = NO; myWebView.backgroundColor = [UIColor clearColor]; OK! 透明效果有了 webview 加载html文本 -(void)addWebView { UIWebView *webView = [[UIWebView alloc]initWithFrame:CGRectMake(10, 10, 300, 200)]; webView.opaque = NO; [self.view addSubview:webView]; webView.backgroundColor = [UIColor cleanColor]; NSString *ring = @&quot;&lt;h3&gt;请客劵是什么？&lt;/h3&gt;&lt;p&gt;&lt;span style=\\&quot;font-size: 14px; background-color: rgb(0, 176, 240);\\&quot;&gt;请客劵是网站推送的拉动用户注册的一种优惠措施！&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span style=\\&quot;font-size: 14px; background-color: rgb(0, 176, 240);\\&quot;&gt;&lt;span style=\\&quot;font-size: 14px; background-color: rgb(255, 255, 255);\\&quot;&gt;请客劵有什么类型？&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span style=\\&quot;font-size: 14px; background-color: rgb(0, 176, 240);\\&quot;&gt;&lt;span style=\\&quot;font-size: 14px; background-color: rgb(255, 255, 255);\\&quot;&gt;&lt;em&gt;请客劵分为www.ifood517.com&lt;span style=\\&quot;font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(0, 112, 192);\\&quot;&gt;限非会员&lt;span style=\\&quot;font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\\&quot;&gt;和&lt;span style=\\&quot;font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(0, 112, 192);\\&quot;&gt;会员之分&lt;span style=\\&quot;font-size: 14px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\\&quot;&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&quot;; [webView loadHTMLString:ring baseURL:[NSURL fileURLWithPath: [[NSBundle mainBundle] bundlePath]]]; webView.delegate = self; } webview 长按 会出现一些选择项 如何禁用长按 - (void)webViewDidFinishLoad:(UIWebView *)webView { // 禁用用户选择 [webView stringByEvaluatingJavaScriptFromString:@&quot;document.documentElement.style.webkitUserSelect=&apos;none&apos;;&quot;]; // 禁用长按弹出框 [webView stringByEvaluatingJavaScriptFromString:@&quot;document.documentElement.style.webkitTouchCallout=&apos;none&apos;;&quot;]; } 关于禁用长按webview后出现的功能项 最近get了一个新的方法, 用手势替换 感觉也是不错的 //添加手势 替换掉webView长按出现的功能选项 UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:nil]; longPress.delegate = self; longPress.minimumPressDuration = 0.4; //个人测试感觉0.4秒是最合适的时间 [webView addGestureRecognizer:longPress]; webView下拉会出现阴影（iOS7.0以下系统） 怎么办呢？ 看看关于UIWebView的API @property(nonatomic,readonly,retain) UIScrollView *scrollView NS_AVAILABLE_IOS(5_0); webview上其实是一个scrollview [webView subviews] objectAtIndex:0]; // 这样就可以找到它了 然后 想避免出现下拉阴影 - //禁掉 `scrollview`的回弹 [(UIScrollView *)[[webView_ subviews] objectAtIndex:0] setBounces:NO]; - //隐藏 for (UIView *subView in [webView_ subviews]) { if ([subView isKindOfClass:[UIScrollView class]]) { for (UIView *shadowView in [subView subviews]) { if ([shadowView isKindOfClass:[UIImageView class]]) { shadowView.hidden = YES; } } } } ok 下班！闪人……","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yongqianvip.github.io/tags/iOS/"}],"keywords":[]}]}